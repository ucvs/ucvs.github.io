{"meta":{"title":"欢迎来到唯美的网站","subtitle":null,"description":"世界上有两种人，一种懂二进制，一种不懂二进制。","author":"Aestheticism","url":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848"},"pages":[{"title":"","date":"2018-03-19T17:58:29.969Z","updated":"2018-03-19T17:58:29.969Z","comments":true,"path":"404.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/404.html","excerpt":"","text":"��ӭ����Ψ������վ The page you are requesting does not exist!"},{"title":"关于唯美","date":"2013-01-18T00:26:01.000Z","updated":"2018-03-19T11:33:20.877Z","comments":true,"path":"about/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-16T20:52:19.000Z","updated":"2018-03-16T21:03:16.114Z","comments":false,"path":"categories/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2014-03-19T12:43:47.000Z","updated":"2018-03-19T13:28:37.335Z","comments":true,"path":"message/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/message/index.html","excerpt":"","text":"欢迎您来到留言板，但我们更鼓励您去“关于我”板块下面留言"},{"title":"tags","date":"2018-03-16T20:56:45.000Z","updated":"2018-03-16T20:56:45.814Z","comments":true,"path":"tags/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/index.html","excerpt":"","text":""},{"title":"search","date":"2018-03-15T22:37:50.000Z","updated":"2018-03-15T22:37:50.611Z","comments":true,"path":"search/index-1.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/search/index-1.html","excerpt":"","text":""},{"title":"search","date":"2018-03-15T23:35:07.000Z","updated":"2018-03-15T23:35:07.638Z","comments":true,"path":"search/index-2.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/search/index-2.html","excerpt":"","text":""},{"title":"search","date":"2018-03-16T08:03:35.000Z","updated":"2018-03-16T08:03:35.042Z","comments":true,"path":"search/index-3.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/search/index-3.html","excerpt":"","text":""},{"title":"search","date":"2018-03-15T22:31:29.000Z","updated":"2018-03-15T22:31:29.882Z","comments":true,"path":"search/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/search/index.html","excerpt":"","text":""}],"posts":[{"title":"AndroidManifest Ambiguity方案实现","slug":"ManifestAmbiguity","date":"2018-03-21T03:56:28.000Z","updated":"2018-03-21T04:06:45.026Z","comments":true,"path":"2018/03/21/ManifestAmbiguity/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2018/03/21/ManifestAmbiguity/","excerpt":"","text":"最近还是有些忙的, 刚好需要做资源保护这一方面的东西, 顺便记录一下Ambiguity方案的一个实现过程, 回头自己忘了也可以看下, 不过资源保护这东西, 针对性还是比较强的,需要不断地有新套路, 不过对于不懂资源文件的人来说还是有一定阻挡作用的… AndroidManifest Ambiguity这个方案实际上就是一张图: 这张图的大致意思是, AndroidManifest.xml中的属性是有对应的属性名(name)和对应的Res Id号的, 比如android:name=”xxxx”这个属性, 有一个对应的属性名(不是android:name)和对应的Res Id号(就是我们反编译经常看到的0Xxxxxxxx之类的), 当Res Id号为0(或者为一个不合法的值,比如0x01017FFF), Android系统是不会对齐进行解析的, 会无视这个属性, 但是对于apktool来说, 是会解析这个属性的, 这样的话虽然反编译的时候没什么问题, 但是在重打包的时候会因为非法Res Id导致重打包失败, 从而对app进行一定程度的保护。 那么, 要搞懂或者实测这个方案, 先要对AndroidManifest.xml这个文件了解才行, 一般说AndroidManifest.xml, 都会用看雪的某张图:以一个示例APK的AndroidManifest.xml进行说明重点的部分 总体的(就是上面那张神图的中间的方块): Magic Number -&gt; 4Bytes, 固定的值0x00080003, 可以看做标识, 上图前四个字节 File Size -&gt; 4Bytes, 整个AndroidManifest.xml的字节数, 在上图是0x00000938 接下来就是StringChunk了, 我把图稍微截大点: Chunk Type -&gt; 4Bytes, 固定的值0x001C0001, 上图的0x8-0xB位 Chunk Size -&gt; 4Bytes, 整个StringChunk的大小, 上图的0xC-0xF位0x0000550 String Count -&gt; 4Bytes, 字符串数目, 上图的0x10-0x13位0x00000022, 表示有34个字符串 Style Count -&gt; 4Bytes, 样式数目, 上图的0x14-0x17位0x00000000, 表示有0个样式 UnKnown -&gt; 4Bytes, 固定值0x00000000, 没用的东西 String Pool Offset -&gt; 4Bytes, 字符串起始偏移, 这个是相对StringChunk的, 以上图为例, String Pool Offset为0x000000A4, 则起始偏移 = A4 + 8 = AC Style Pool Offset -&gt; 4Bytes, 样式起始偏移, 也是相对StringChunk的, 上图0x20-0x23为0x00000000, 表示没有Style String Offset数组 -&gt; String Count * 4Bytes, 以上图为例, 大小为 0x22 * 4 = 88, 上图的String Offset数组范围为0x24 - 0xAB Style Offset数组 -&gt; Style Count * 4Bytes, 跟String Offset相同, 这个例子明显没有这一块 String Data -&gt; 字符串数据块, 下面分析 Style Data -&gt; 样式数据块, 下面分析 首先分析String Offset数组, 上面我们说了范围是0x24-0xAC, 那么先取0x24-0x27这四位, 即第一个字符串的偏移, 为0x00000000, 即为0 + String Pool Offset + 8 = 0 + A4 + 8 = AC, 那么看一下上图的0xAC位: 0B 00 76 00 65 00 72 00 73 00 .... 这里我们要说明一个字符串在AndroidManifest.xml的存储方式是UTF16, 并且前面是先存字符数目, 最后填充00(相当于\\0这种东西): 比如有一个字符串fuck, 转为十六进制ASCII码即为66 75 63 6B, 转为UTF16则为66 00 75 00 63 00 6B 00, fuck字符为四个, 那么加上04 00, 最后填充00 00, 就成了: // fuck的最终存储形式 04 00 66 00 75 00 63 00 6B 00 00 00 这里我圈了出来: 对于Style, 跟String的分析是一样的, 可以自己拿个APK看下。 然后就是ResourceChunk了: Chunk Type -&gt; 4Bytes, 固定值0x00080180, 看0x00000558 - 0x0000055B位 Chunk Size -&gt; 4Bytes, 整个ResourceChunk的大小, 以上图为例, 0x0000055C-0x0000055F位, 为0x0000002C ResourceIds数组 -&gt; ChunkSize / 4 - 2个, 每个4Bytes, 表示对应的Res Id值 中间有个String NameSpace Chunk 部分, 可以跳过也可以停下来看下, 范围为0x00000584 - 0x0000059B: Chunk Type -&gt; 4Bytes, 固定值0x00100100 Chunk Size -&gt; 4Bytes, 这里上图的值为18即24个字节, 所以范围是0x00000584-0x0000059B Line Number -&gt; 4Bytes Unknown -&gt; 4Bytes Prefix -&gt; 4Bytes Uri -&gt; 4Bytes 最后是TagChunk部分, TagChunk有很多个Chunk(Start Tag Chunk 或者End Tag Chunk), 按示例是从0x0000059C开始: Chunk Type -&gt; 4Bytes, 有两个固定值, 为0x00100102表示这是一个Start Tag, 0x00100103表示这是一个End Tag Chunk Size -&gt; 4Bytes Line Number -&gt; 4Bytes, 不知道什么用 Unknown -&gt; 4Bytes, 固定值0xFFFFFFFF, 没用的东西 Namespace uri -&gt; 4Bytes, 这个可以不管, 对应上面的String NameSpace Chunk Name -&gt; 4Bytes, 对应StringChunk的字符串索引 Flags -&gt; 4Bytes, 固定值0x00140014, 没什么用 Attr Count -&gt; 4Bytes, 这个Tag的属性数目 Class Attribute -&gt; 4Bytes, 不知道干什么 Attr 数组 -&gt; 数组元素数目为Attr Count, 每个Attr都是一个20字节的结构体, 所以总长度为Attr Count * 20 上面说Attr是个20字节的结构体, 这里进行简要说明: // uint32实际上表示是4Bytes type Attr struct { Uri uint32 // 对应字符串索引, 比如上图的&quot;application&quot;在字符串索引是0A, Application Tag Chunk所有的attr的uri都是0A Name uint32 // 这个很关键, 也是个索引, 但是同时表示String和Resource索引 String uint32 // 指向字符串索引, 当Type为0x03000008时与Data相等 Type uint32 // 类型, 比如0x030000008 表示这是个android:name Data uint32 // 数据 } 上面这些东西, 不能用光看的, 要自己用一个示例一步一步分析下来才会印象深刻些, 关于分析二进制文件的, 可以用C32ASM, 或者神奇010 Editor(导入AXMLTemplate,直接都给你分好了, 看起来更容易) 把上面的结构大致了解了以后, 我们需要定义一个方案实现, 分别是针对StringChunk, ResourceChunk, 以及Application TagChunk进行手术, 在本例中用go(js用多了, 速成go感觉很不适应规则)撸了一个, 首先是StringChunk模块: 1. 确定插入字符串a, b 2. 将字符串a, b插入string data块(需要对齐, 如果上面你仔细看, 会发现都是4Bytes的段, 而字符串是UTF16即2Bytes的, 所以要进行4Bytes对齐) 3. 计算两个字符串的偏移值, 添加进string offset数组中 4. 修改起始string offset值(+8, 因为第三步增加了8个字节, 所以起始偏移值要加8) 5. 如果有style的话(判断起始style offset是否为0), 那么起始style offset需要修正(+8 + 两个字符串的长度) 6. 修正string count 7. 修正string chunk size 8. 修正fileSize // 插入字符串aonosora.class, name func modifyStringChunk(axml * AXML, axmlBytes []byte) []byte { // UTF8ToUTF16() 将其转为可以塞进二进制文件的字符串: 0x0E 0x00 0x60 0x00 0x6F 0x00 .... 0x73 0x00 0x00 0x00 appendStr1 := UTF8ToUTF16([]byte{ 0x61,0x6F,0x6E,0x6F,0x73,0x6F,0x72, 0x61,0x2E,0x63,0x6C,0x61,0x73,0x73, }) // 同转为字符串: 0x04 0x00 0x6E 0x00 0x61 0x00 0x6D 0x00 0x65 0x00 0x00 0x00 appendStr2 := UTF8ToUTF16([]byte{ 0x6E,0x61,0x6D,0x65, }) // 计算出字符串data块长度 var strLen uint32 if axml.StyleOffset == 0 { // 没有style块的情况, string data块就是StringChunk的最后一块, 直接用ChunkSize去减 strLen = axml.StringChunkSize - axml.StringOffset } else { // 如果有Style的情况, 字符串data块为StyleOffset - StringOffset strLen = axml.StyleOffset - axml.StringOffset } // string data块的结尾偏移 strEndOffset := axml.StringOffset + 0x8 + strLen // 连续插入字符串 axmlBytes = append(axmlBytes[:strEndOffset], append(appendStr1, append(appendStr2, axmlBytes[strEndOffset:]...)...)...) // 对齐String, 一般在有Style的情况才有改变效果 // 因为String在这里是UTF16形式的, 而其他字段都是UInt32形式的, 所以要进行对齐 // 对齐的方式在StringData的后面插入00 strLenAlignedOffset := strLen strLenAligned := (strLenAlignedOffset + uint32(0x03)) &amp; (^uint32(0x03)) strLenAlignedOffset2 := strLenAligned + uint32(len(appendStr1)) strLenAligned2 := (strLenAlignedOffset2 + uint32(0x03)) &amp; (^uint32(0x03)) // 计算出对齐需要的空白字节数 alignBytesLen := strLenAligned2 - strLenAlignedOffset2 + strLenAligned - strLenAlignedOffset externSize := 0x8 + uint32(len(appendStr1)) + uint32(len(appendStr2)) strEndOffset = strEndOffset + uint32(len(appendStr1)) + uint32(len(appendStr2)) // 一次填充空白字节到string data块中 for i:= 0; i &lt; int(alignBytesLen); i++ { axmlBytes = append(axmlBytes[:strEndOffset], append([]byte{0x00}, axmlBytes[strEndOffset:]...)...) strEndOffset += 1 } externSize = externSize + alignBytesLen // 增加StringOffset偏移索引表 // 字符串aonosora.class的相对Offset // UInt32ToBytes()将一个UInt32转为一个长度为4的字节段 str1OffsetIndex := UInt32ToBytes(strLen) // 字符串name的相对Offset str2OffsetIndex := UInt32ToBytes(strLen + uint32(len(appendStr1))) // 计算出string offset数组的结尾offset strEndOffsetIndex := 36 + axml.StringCount * 4 // 填充两个新的字符串对应的偏移值 axmlBytes = append(axmlBytes[:strEndOffsetIndex], append(str1OffsetIndex, append(str2OffsetIndex, axmlBytes[strEndOffsetIndex:]...)...)...) axml.StringCount = axml.StringCount + 2 axml.StringOffset = axml.StringOffset + 0x8 // 修正StringOffset起始偏移 fixBytes(axmlBytes, axml.StringOffset, 28) // 修正StringCount fixBytes(axmlBytes, axml.StringCount, 16) // 有Style的情况要修正StyleOffset if axml.StyleOffset != 0 { axml.StyleOffset = axml.StyleOffset + externSize fixBytes(axmlBytes, axml.StyleOffset, 32) } // 修正StringChunkSize axml.StringChunkSize = axml.StringChunkSize + externSize fixBytes(axmlBytes, axml.StringChunkSize, 12) axml.FileSize = uint32(len(axmlBytes)) // 由于增加了字节, 原先的Offset需要重新设置 axml.ResourceChunkOffset = axml.ResourceChunkOffset + externSize axml.AppChunkOffset = axml.AppChunkOffset + externSize return axmlBytes } 然后是ResourceChunk, 这个简单些: 1. 由上一步计算出新的String Count(字符串个数), 让这个数减去现有Resource数得出需要填充的Resource个数 2. 需要填充的Resource全是非法的Res Id值 3. 修正ResourceChunkSize(+ 填充的Resource个数 * 4) 4. 修正FileSize func modifyResourceChunk(axml * AXML, axmlBytes []byte) []byte { resourceCounts := axml.ResourceChunkSize / 4 - 2 // 计算出需要填充的ResourceIds的个数, 全部填充为0x00即可, 因为字符串的个数远大于资源的个数, 所以用StringCount - resourceCounts paddingCounts := axml.StringCount - resourceCounts // 计算出从哪个偏移开始填充 paddedStartOffset := axml.ResourceChunkOffset + axml.ResourceChunkSize for i := 0; i &lt; int(paddingCounts); i++ { // 这里特别对第一个插入的字符串用了个Res Id的非法值(尽管0也是非法, 其实都可以用0) if i == int(paddingCounts) - 2 { axmlBytes = append(axmlBytes[:paddedStartOffset], append(UInt32ToBytes(uint32(0x01017FFF)), axmlBytes[paddedStartOffset:]...)...) } else { axmlBytes = append(axmlBytes[:paddedStartOffset], append(UInt32ToBytes(uint32(0x00000000)), axmlBytes[paddedStartOffset:]...)...) } paddedStartOffset = paddedStartOffset + 4 } // 修复ResourceChunkSize axml.ResourceChunkSize = axml.ResourceChunkSize + paddingCounts * 4 fixBytes(axmlBytes, axml.ResourceChunkSize, axml.ResourceChunkOffset + 4) axml.FileSize = uint32(len(axmlBytes)) // 增加字节改变Offset位置 axml.AppChunkOffset = axml.AppChunkOffset + paddingCounts * 4 return axmlBytes } 最后是Application TagChunk, 相对也简单些: 1. 构造出一个Attr 结构体(属性名和Res Id索引都是我们插入的最后一个字符串的索引值, URI为Application对应结构体的URI) 2. 直接插入到这个TagChunk中 3. 修正这个TagChunk的attr count(+1) 4. 修正这个TagChunk的Chunk Size(+20) 5. 修正FileSize func modifyTagChunk(axml * AXML, axmlBytes []byte) []byte { appChunkSize := BytesToUInt32(axmlBytes[axml.AppChunkOffset + 4: axml.AppChunkOffset + 8]) appChunkAttrCount := BytesToUInt32(axmlBytes[axml.AppChunkOffset + 28: axml.AppChunkOffset + 32]) // 取得AppChunk 结尾偏移 appChunkEndOffset := axml.AppChunkOffset + appChunkSize // 表明属性名为name, 属性值为Android:name = &quot;aonosora.class&quot; attr := new(Attr) attr.Uri = axml.AppURIIndex attr.Name = axml.StringCount - 1 attr.String = axml.StringCount - 2 attr.Type = 0x03000008 attr.Data = axml.StringCount - 2 attrRefValue := reflect.ValueOf(attr).Elem() for i := 0; i &lt; attrRefValue.NumField(); i++ { value := uint32(attrRefValue.Field(i).Uint()) axmlBytes = append(axmlBytes[:appChunkEndOffset], append(UInt32ToBytes(value), axmlBytes[appChunkEndOffset:]...)...) appChunkEndOffset += 4 } // 修正AppChunk Attr Count fixBytes(axmlBytes, appChunkAttrCount + 1, axml.AppChunkOffset + 28) // 修正AppChunk Size fixBytes(axmlBytes, appChunkSize + 20, axml.AppChunkOffset + 4) axml.FileSize = uint32(len(axmlBytes)) return axmlBytes } 跑一下程序, 运行出来是这个鬼样子(用的Android_Killer, 因为我特别对ShakaApktool进行了设置才能反编译, 不然连反编译都不行了, Android逆向助手跑出来是个空文件夹, ApkToolKit直接提示失败): 不过, 这种方式跟多数资源保护一样, 具有比较强的针对性(就是针对apktool这个东西), 很多的Android反编译工具(比如Android逆向助手, Android_Killer, ApkToolKit),看文件目录的话, 其实都差不多的(包含apktool, dex2jar, aapt这些基本的东西), 所以一防住apktool的话, 很多工具就是用不了的, 这对于隔离新手来说还是有用的, 缺点也是针对性比较强, 毕竟这种方式其实就是利用反编译工具的逻辑漏洞, 那么工具做一下更新就行了, apktool这个东西在github上是开源的: https://github.com/iBotPeaches/Apktool, 版本是不断更新的, 只要它做了对应的更新, 那么方案就无效了。 http://blog.csdn.net/weimeig/article/details/79637920","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Android新特性ConstraintLayout约束布局读书笔记","slug":"ConstraintLayout","date":"2017-03-27T01:10:23.000Z","updated":"2018-03-27T01:50:04.575Z","comments":true,"path":"2017/03/27/ConstraintLayout/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2017/03/27/ConstraintLayout/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（https://blog.csdn.net/weimeig/article/details/79706819），请尊重他人的辛勤劳动成果，谢谢 本来打算自己写一篇，看到郭霖大神已经写了，不打算重复造轮子，决定参考郭神的文章下，写一篇学习ConstraintLayout约束布局的读书笔记。同时感谢《第一行代码》作者郭霖大神的无私分享。 首先说一下什么是约束布局 在2016年的Google I/O大会上 , Google 发布了Android Studio 2.2预览版，同时也发布了Android 新的布局方案 ConstraintLayout ， 但是最近的一年也没有大规模的使用。2017年Google发布了 Android Studio 2.3 正式版，在 Android Studio 2.3 版本中新建的Module中默认的布局就是 ConstraintLayout 。如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.constraintlayout.app.Main2Activity&quot;&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 下面我们开始用边学边练的方式来进行学习，首先打开你的Android Studio，并新建一个ConstraintLayoutTest项目。另外，确保你的Android Studio是2.2或以上版本。 dependencies { compile &apos;com.android.support.constraint:constraint-layout:1.0.0-beta4&apos; } 现在打开res/layout/activity_main.xml文件，由于这是一个新建的空项目，Android Studio会自动帮我们创建好一个布局，如下图所示。 不过，Android Studio自动创建的这个布局默认使用的是RelativeLayout，我们可以通过如下操作将它转换成ConstraintLayout。 转换完成之后，原RelativeLayout中的内容也会自动转换到ConstraintLayout中，比如图中的TextView。如果你不需要它的话，可以选中这个控件，然后按键盘上的Delete键即可删除 我们可以看到，现在主操作区域内有两个类似于手机屏幕的界面，左边的是预览界面，右边的是蓝图界面。这两部分都可以用于进行布局编辑工作，区别是左边部分主要用于预览最终的界面效果，右边部分主要用于观察界面内各个控件的约束情况。 基本操作下面我们来学习一些具体的操作吧，ConstraintLayout的基本用法很简单，比如我们想要向布局中添加一个按钮，那么只需要从左侧的Palette区域拖一个Button进去就可以了，如下图所示。 虽说现在Button已经添加到界面上了，但是由于我们还没有给Button添加任何的约束，因此Button并不知道自己应该出现在什么位置。现在我们在预览界面上看到的Button位置并不是它最终运行后的实际位置，如果一个控件没有添加任何约束的话，它在运行之后会自动位于界面的左上角。 那么下面我们就来给Button添加约束，每个控件的约束都分为垂直和水平两类，一共可以在四个方向上给控件添加约束，如下图所示。 上图中Button的上下左右各有一个圆圈，这圆圈就是用来添加约束的，我们可以将约束添加到ConstraintLayout，也可以将约束添加到另一个控件。比如说，想让Button位于布局的右下角，就可以这样添加约束，如下图所示。 我们给Button的右边和下边添加了约束，因此Button就会将自己定位到布局的右下角了。类似地，如果我们想要让Button居中显示，那么就需要给它的上下左右都添加约束，如下图所示。 这就是添加约束最基本的用法了。 除此之外，我们还可以使用约束让一个控件相对于另一个控件进行定位。比如说，我们希望再添加一个Button，让它位于第一个Button的正下方，并且间距64dp，那么操作如下所示。 现在添加约束的方式我们已经学完了，那么该怎样删除约束呢？其实也很简单，删除约束的方式一共有三种，第一种用于删除一个单独的约束，将鼠标悬浮在某个约束的圆圈上，然后该圆圈会变成红色，这个时候单击一下就能删除了，如下图所示。 第二种用于删除某一个控件的所有约束，选中一个控件，然后它的左下角会出现一个删除约束的图标，点击该图标就能删除当前控件的所有约束了，如下所示。 第三种用于删除当前界面中的所有约束，点击工具栏中的删除约束图标即可，如下图所示。 Inspector这样我们就把ConstraintLayout的基本用法学完了，接下来我们开始学习一些进阶的内容。 当你选中任意一个控件的时候，在右侧的Properties区域就会出现很多的属性选项，如下图所示。 在这里我们就可以设置当前控件的所有属性，如文本内容、颜色、点击事件等等。这些功能都非常简单，我就不再进行详细介绍，大家自己点一点就会操作了。 需要我们重点掌握的是Properties区域的上半部分，这部分也被称为Inspector。 首先可以看到，在Inspector中有一个纵向的轴和一个横向的轴，这两个轴也是用于确定控件的位置的。我们刚才给Button的上下左右各添加了一个约束，然后Button就能居中显示了，其实就是因为这里纵横轴的值都是50。如果调整了纵横轴的比例，那么Button的位置也会随之改变，如下图所示。 不过，虽然我们将横轴的值拖动到了100，但是Button并没有紧贴到布局的最右侧，这是为什么呢？实际上，Android Studio给控件的每个方向上的约束都默认添加了一个16dp的间距，从Inspector上面也可以明显地看出来这些间距的值。如果这些默认值并不是你想要的，可以直接在Inspector上进行修改，如下图所示： 可以看到，修改成0之后Button右侧的间距就没了。 接下来我们再来学习一下位于Inspector最中间的那个正方形区域，它是用来控制控件大小的。一共有三种模式可选，每种模式都使用了一种不同的符号表示，点击符号即可进行切换。 表示wrap content，这个我们很熟悉了，不需要进行什么解释。 表示固定值，也就是给控件指定了一个固定的长度或者宽度值。 表示any size，它有点类似于match parent，但和match parent并不一样，是属于ConstraintLayout中特有的一种大小控制方式，下面我们来重点讲解一下。 首先需要说明，在ConstraintLayout中是有match parent的，只不过用的比较少，因为ConstraintLayout的一大特点就是为了解决布局嵌套，既然没有了布局嵌套，那么match parent也就没有多大意义了。 而any size就是用于在ConstraintLayout中顶替match parent的，先看一下我们怎样使用any size实现和match parent同样的效果吧。比如说我想让Button的宽度充满整个布局，操作如下图所示。 可以看到，我们将Button的宽度指定成any size，它就会自动充满整个布局了。当然还要记得将Button左侧的间距设置成0才行。 那有的朋友可能会问了，这和match parent有什么区别呢？其实最大的区别在于，match parent是用于填充满当前控件的父布局，而any size是用于填充满当前控件的约束规则。举个例子更好理解，如果我们有一个新的Button，它的其中一个约束是添加到当前这个Button上的，那么any size的效果也会发生改变，如下图所示。 通过上图的演示，相信你已经很好地理解any size的作用了。 Guidelines现在你已经对ConstraintLayout比较熟悉，并且能使用ConstraintLayout来编写一些简单的界面了。不过目前有一个问题可能还比较头疼，刚才我们已经实现了让一个按钮居中对齐的功能，如果我们想让两个按钮共同居中对齐该怎么实现呢？ 其实这个需求很常见，比如说在应用的登录界面，都会有一个登录按钮和一个注册按钮，不管它们是水平居中也好还是垂直居中也好，但肯定都是两个按钮共同居中的。 想要实现这个功能，仅仅用我们刚刚学的那些知识是不够的，这需要用到ConstraintLayout中的一个新的功能，Guidelines。 下面我们还是通过实际操作来学习一下Guidelines的用法吧。比如现在已经向界面中添加了登录和注册这两个按钮，如下图所示。 然后我们希望让这两个按钮在水平方向上居中显示，在垂直方向上都距离底部64dp，那么就需要先添加一个垂直方向上的Guideline，如下图所示。 我来对上图中的操作进行一下解释。首先点击通知栏中的Guidelines图标可以添加一个垂直或水平方向上的Guideline，这里我们需要的是垂直方向上的。而Guideline默认是使用的dp尺，我们需要选中Guideline，并点击一下最上面的箭头图标将它改成百分比尺，然后将垂直方向上的Guideline调整到50%的位置，这样就将准备工作做好了。 接下来我们开始实现让两个按钮在水平方向上居中显示，并距离底部64dp的功能，如下图所示。 可以看到，我们给登录按钮的右边向Guideline添加约束，登录按钮的下面向底部添加约束，并拖动按钮让它距离底部64dp。然后给注册按钮的左边向Guideline添加约束，注册按钮的下面向登录按钮的下面添加约束。这样就实现了让两个按钮在水平方向上居中显示，在垂直方向上都距离底部64dp的功能了。 自动添加约束不过如果界面中的内容变得复杂起来，给每个控件一个个地添加约束也是一件很繁琐的事情。为此，ConstraintLayout中支持自动添加约束的功能，可以极大程度上简化那些繁琐的操作。 自动添加约束的方式主要有两种，一种叫Autoconnect，一种叫Inference，我们先来看第一种。 想要使用Autoconnect，首先需要在工具栏中将这个功能启用，默认情况下Autoconnect是不启用的，如下图所示。 Autoconnect可以根据我们拖放控件的状态自动判断应该如何添加约束，比如我们将Button放到界面的正中央，那么它的上下左右都会自动地添加上约束，如下图所示。 然后我们在这个Button的下方再放置一个Button，效果如下。 可以看到，只需要将Button拖放到界面上，Autoconnect会判断我们的意图，并自动给控件添加约束。不过Autoconnect是无法保证百分百准确判断出我们的意图的，如果自动添加的约束并不是你想要的话，还可以在任何时候进行手动修改。总之，可以把它当成一个辅助工具，但不能完全靠它去添加控件的约束。 以上是Autoconnect的用法，接下来我们看一下Inference的用法。Inference也是用于自动添加约束的，但它比Autoconnect的功能要更为强大，因为AutoConnect只能给当前操作的控件自动添加约束，而Inference会给当前界面中的所有元素自动添加约束。因而Inference比较适合用来实现复杂度比较高的界面，它可以一键自动生成所有的约束。 下面我们就通过一个例子来演示一下Inference的用法，比如界面上现在有两个TextView，两个EditText，和两个Button，如下图所示。 接下来我们先将各个控件按照界面设计的位置进行摆放，摆放完成之后点击一下工具栏上的Infer Constraints按钮，就能为所有控件自动添加约束了，如下图所示。 现在运行一下程序，最终效果如下图所示： ConstraintLayout约束布局的常用方法layout_constraintTop_toTopOf // 将所需视图的顶部与另一个视图的顶部对齐。 layout_constraintTop_toBottomOf // 将所需视图的顶部与另一个视图的底部对齐。 layout_constraintBottom_toTopOf // 将所需视图的底部与另一个视图的顶部对齐。 layout_constraintBottom_toBottomOf // 将所需视图的底部与另一个视图的底部对齐。 layout_constraintLeft_toTopOf // 将所需视图的左侧与另一个视图的顶部对齐。 layout_constraintLeft_toBottomOf // 将所需视图的左侧与另一个视图的底部对齐。 layout_constraintLeft_toLeftOf // 将所需视图的左边与另一个视图的左边对齐。 layout_constraintLeft_toRightOf // 将所需视图的左边与另一个视图的右边对齐。 layout_constraintRight_toTopOf // 将所需视图的右对齐到另一个视图的顶部。 layout_constraintRight_toBottomOf // 将所需视图的右对齐到另一个的底部。 layout_constraintRight_toLeftOf // 将所需视图的右边与另一个视图的左边对齐。 layout_constraintRight_toRightOf // 将所需视图的右边与另一个视图的右边对齐。 当控件刚拖进布局时候，有如下两行代码。通常是没有添加约束的后果，添加约束熟悉后，可以考虑删除以下意义不大的两条 tools:layout_editor_absoluteX=&quot;8dp&quot; tools:layout_editor_absoluteY=&quot;8dp&quot; 我们来看一下以下代码 我们会问，为什么Button 是居中显示的？因为在上面的布局中有两个重要的属性没有写出来，但是却有默认的属性值，那就是水平、垂直的偏移比例。 我们通过设置偏移量，可以控制控件的偏移位置 使用ConstraintLayout约束布局可以有效减少布局的嵌套层数，如下（观看效果请切换至横屏）： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:layout_editor_absoluteY=&quot;81dp&quot; tools:layout_editor_absoluteX=&quot;0dp&quot;&gt; &lt;android.support.constraint.Guideline android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/guideline2&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.67&quot; /&gt; &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.34&quot; /&gt; &lt;android.support.constraint.Guideline android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/guideline4&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.75&quot; /&gt; &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.58&quot; /&gt; &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline7&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.41&quot; /&gt; &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.25&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginTop=&quot;2dp&quot; app:srcCompat=&quot;@color/colorAccent&quot; android:layout_marginRight=&quot;2dp&quot; android:layout_marginLeft=&quot;2dp&quot; android:layout_marginBottom=&quot;2dp&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/imageView6&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/imageView2&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/imageView10&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView10&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginBottom=&quot;2dp&quot; android:layout_marginLeft=&quot;0dp&quot; android:layout_marginRight=&quot;2dp&quot; android:layout_marginTop=&quot;2dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintLeft_toLeftOf=&quot;@+id/guideline4&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; app:srcCompat=&quot;@color/colorAccent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView9&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginBottom=&quot;2dp&quot; android:layout_marginLeft=&quot;0dp&quot; android:layout_marginRight=&quot;2dp&quot; android:layout_marginTop=&quot;2dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/imageView8&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintLeft_toLeftOf=&quot;@+id/guideline4&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; app:srcCompat=&quot;@color/colorAccent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView8&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginBottom=&quot;2dp&quot; android:layout_marginLeft=&quot;0dp&quot; android:layout_marginRight=&quot;2dp&quot; android:layout_marginTop=&quot;2dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintLeft_toLeftOf=&quot;@+id/guideline4&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView3&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; app:srcCompat=&quot;@color/colorAccent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView7&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginBottom=&quot;2dp&quot; android:layout_marginLeft=&quot;2dp&quot; android:layout_marginRight=&quot;2dp&quot; android:layout_marginTop=&quot;2dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/imageView6&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView3&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; app:srcCompat=&quot;@color/colorAccent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView6&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginBottom=&quot;2dp&quot; android:layout_marginLeft=&quot;2dp&quot; android:layout_marginRight=&quot;2dp&quot; android:layout_marginTop=&quot;2dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintLeft_toLeftOf=&quot;@+id/guideline7&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/guideline5&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView3&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; app:srcCompat=&quot;@color/colorAccent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView5&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginBottom=&quot;2dp&quot; android:layout_marginLeft=&quot;2dp&quot; android:layout_marginRight=&quot;2dp&quot; android:layout_marginTop=&quot;2dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/imageView4&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/guideline7&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView3&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; app:srcCompat=&quot;@color/colorAccent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView4&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginBottom=&quot;2dp&quot; android:layout_marginLeft=&quot;2dp&quot; android:layout_marginRight=&quot;0dp&quot; android:layout_marginTop=&quot;2dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/guideline6&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView3&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; app:srcCompat=&quot;@color/colorAccent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginBottom=&quot;2dp&quot; android:layout_marginLeft=&quot;2dp&quot; android:layout_marginRight=&quot;0dp&quot; android:layout_marginTop=&quot;2dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/guideline6&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView2&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; app:srcCompat=&quot;@color/colorAccent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginBottom=&quot;2dp&quot; android:layout_marginLeft=&quot;2dp&quot; android:layout_marginRight=&quot;0dp&quot; android:layout_marginTop=&quot;2dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/guideline6&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:srcCompat=&quot;@color/colorAccent&quot; /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; &lt;!--app:layout_constraintHorizontal_bias 水平偏移量，取值0~1 ,默认0.5 app:layout_constraintVertical_bias 竖直偏移量 app:layout_contraint本源_to目标=&quot;目标id&quot; --&gt; 运行效果如下：","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Intent实现Android间的页面跳转","slug":"AndroidIntent","date":"2016-07-12T07:11:59.000Z","updated":"2018-03-23T07:43:20.750Z","comments":true,"path":"2016/07/12/AndroidIntent/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2016/07/12/AndroidIntent/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（https://blog.csdn.net/weimeig/article/details/79666786），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的Android基础薄弱的问题，决定出一套Android基础教程，帮助大家复习，巩固Android基础，今天要讲的是Android中的Intent实现Android间的页面跳转。 增加Acrivity页面时，首先需要在MainActivity中对页面注册，比如 新建被跳转的页面OtherActivity，其对应的xml文件如下 activity_other &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;第二个Activity&quot;/&gt; &lt;/LinearLayout&gt; Java代码 OtherActivity import android.support.v7.app.AppCompatActivity; import android.view.View; public class OtherActivity extends AppCompatActivity { @Override public void setContentView(View view) { super.setContentView(R.layout.activity_other); } } 程序主界面activity_main.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;第一个Activity&quot;/&gt; &lt;Button android:id=&quot;@+id/start_btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面跳转&quot;/&gt; &lt;/LinearLayout&gt; Java代码 MainActivity import android.content.Intent; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { private Button startButton; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); startButton = findViewById(R.id.start_btn); startButton.setOnClickListener(new ButtonListener()); } class ButtonListener implements View.OnClickListener{ @Override public void onClick(View v) { //当点击事件触发后执行，启动OtherActivity //创建一个Intent对象 Intent intent =new Intent(); intent.setClass(MainActivity.this,OtherActivity.class);//从MainActivity跳转到OtherActivity startActivity(intent); } } } 另外除了上述的显式Intent，还有隐式Intent，隐式Intent可以用来传递数组及动作状态 比如在MainActivity中 //当点击事件触发后执行，启动OtherActivity //创建一个Intent对象 Intent intent =new Intent(); intent.setClass(MainActivity.this,OtherActivity.class);//从MainActivity跳转到OtherActivity intent.putExtra(&quot;姓名&quot;,&quot;小李&quot;); startActivity(intent); 在被跳转的OtherActivity中 Intent intent =new Intent(); String name = intent.getStringExtra(&quot;姓名&quot;); 可以接收由MainActivity传来的数据 又或者 Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); startActivity(intent); 可以调用拨打电话界面并设定预设号码为10086 还可以设置网址的跳转，显示地理位置等 如设置为跳转打开网址时，需要在AndroidManifast中注册一下 如下： &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:scheme=&quot;http&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt;","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"ImageView和ImageButton","slug":"ImageViewAndImageBtn","date":"2016-07-10T07:25:57.000Z","updated":"2018-03-23T07:36:12.699Z","comments":true,"path":"2016/07/10/ImageViewAndImageBtn/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2016/07/10/ImageViewAndImageBtn/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 android:scaleType=&quot;center&quot; //ImageView的缩放位置属性 项目中使用ImageButton,但是给图片设置具体尺寸(width,height)之后,发现还是原来的大小,为了保持图片的原始像素,并没有给ImageButton设置ScaleType,后来将ImageButton换成ImageView之后就ok了(并不是唯一解决方案) 于是,想搞明白ImageView和ImageButton之间到底有什么不同,发现两者之间还是有不小的区别. 源码的角度看继承关系,一目了然: 下面分几种不同的情况去说明两者之间的差别: 1,不设置具体宽高 &lt;code class=&quot;hljs xml has-numbering&quot; style=&quot;display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: &apos;Source Code Pro&apos;, monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;&quot;&gt;&lt;span class=&quot;hljs-tag&quot; style=&quot;color: rgb(0, 102, 102); box-sizing: border-box;&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot; style=&quot;box-sizing: border-box; color: rgb(0, 0, 136);&quot;&gt;ImageView &lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:background&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;#00f&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:src&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;@drawable/search&quot;&lt;/span&gt;/&gt;&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot; style=&quot;color: rgb(0, 102, 102); box-sizing: border-box;&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot; style=&quot;box-sizing: border-box; color: rgb(0, 0, 136);&quot;&gt;ImageButton &lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_marginTop&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;20dp&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:background&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;#0f0&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:src&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;@drawable/search&quot;&lt;/span&gt;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;ul class=&quot;pre-numbering&quot; style=&quot;box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);&quot;&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;1&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;2&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;3&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;4&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;5&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;6&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;7&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;8&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;9&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;10&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;11&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;12&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;pre-numbering&quot; style=&quot;box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);&quot;&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;1&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;2&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;3&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;4&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;5&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;6&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;7&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;8&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;9&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;10&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;11&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;12&lt;/li&gt;&lt;/ul&gt; 效果是这样的: 效果就很明显了,ImageView会根据设置的具体宽高尺寸变化,但是ImageButton只会显示图片的原始像素大小.当然,给ImageButton设置scaletype属性是可以完成ImageView的效果,但是那样会是图片失真. 3,设置背景选择器 &lt;code class=&quot;hljs xml has-numbering&quot; style=&quot;display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: &apos;Source Code Pro&apos;, monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;&quot;&gt;&lt;span class=&quot;hljs-tag&quot; style=&quot;color: rgb(0, 102, 102); box-sizing: border-box;&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot; style=&quot;box-sizing: border-box; color: rgb(0, 0, 136);&quot;&gt;ImageView &lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:clickable&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:background&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;#00f&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:src&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;@drawable/search_selector&quot;&lt;/span&gt;/&gt;&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot; style=&quot;color: rgb(0, 102, 102); box-sizing: border-box;&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot; style=&quot;box-sizing: border-box; color: rgb(0, 0, 136);&quot;&gt;ImageButton &lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_marginTop&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;20dp&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:background&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;#0f0&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:src&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;@drawable/search_selector&quot;&lt;/span&gt;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;ul class=&quot;pre-numbering&quot; style=&quot;box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);&quot;&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;1&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;2&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;3&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;4&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;5&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;6&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;7&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;8&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;9&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;10&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;11&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;12&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;13&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;pre-numbering&quot; style=&quot;box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);&quot;&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;1&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;2&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;3&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;4&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;5&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;6&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;7&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;8&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;9&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;10&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;11&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;12&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;13&lt;/li&gt;&lt;/ul&gt; 注意:ImageView要想使选择器效果生效,需要让控件是有焦点的,这里加上clickable=true处理一下ImageButton就不需要处理,因为源码中,ImageButton的构造中,已经setFocusable(true)处理过了 效果都一样的,选择器都会生效,这里就不上图了.同时,将宽高改成的具体尺寸,效果也是一样的,选择器都会生效 将两者的src换成background试了一下: &lt;code class=&quot;hljs xml has-numbering&quot; style=&quot;display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: &apos;Source Code Pro&apos;, monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;&quot;&gt;&lt;span class=&quot;hljs-tag&quot; style=&quot;color: rgb(0, 102, 102); box-sizing: border-box;&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot; style=&quot;box-sizing: border-box; color: rgb(0, 0, 136);&quot;&gt;ImageView &lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:clickable&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:background&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;@drawable/search_selector&quot;&lt;/span&gt;/&gt;&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot; style=&quot;color: rgb(0, 102, 102); box-sizing: border-box;&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot; style=&quot;box-sizing: border-box; color: rgb(0, 0, 136);&quot;&gt;ImageButton &lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_marginTop&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;20dp&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:background&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;@drawable/search_selector&quot;&lt;/span&gt;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;ul class=&quot;pre-numbering&quot; style=&quot;box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);&quot;&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;1&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;2&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;3&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;4&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;5&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;6&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;7&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;8&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;9&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;10&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;11&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;pre-numbering&quot; style=&quot;box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);&quot;&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;1&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;2&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;3&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;4&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;5&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;6&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;7&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;8&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;9&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;10&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;11&lt;/li&gt;&lt;/ul&gt; 效果也是一样的,选择器都会生效同时,将宽高改成的具体尺寸,效果也是一样的,选择器都会生效 所以,在选择器的使用上,两者基本没有差别,要说差别,那就是ImageView需要处理一下焦点问题吧 4,设置background(无具体宽高) &lt;code class=&quot;hljs xml has-numbering&quot; style=&quot;display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: &apos;Source Code Pro&apos;, monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;&quot;&gt;&lt;span class=&quot;hljs-tag&quot; style=&quot;color: rgb(0, 102, 102); box-sizing: border-box;&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot; style=&quot;box-sizing: border-box; color: rgb(0, 0, 136);&quot;&gt;ImageView &lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:clickable&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:background&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;@drawable/search_selected&quot;&lt;/span&gt;/&gt;&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot; style=&quot;color: rgb(0, 102, 102); box-sizing: border-box;&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot; style=&quot;box-sizing: border-box; color: rgb(0, 0, 136);&quot;&gt;ImageButton &lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:layout_marginTop&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;20dp&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot; style=&quot;box-sizing: border-box; color: rgb(102, 0, 102);&quot;&gt;android:background&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot; style=&quot;box-sizing: border-box; color: rgb(0, 136, 0);&quot;&gt;&quot;@drawable/search_selected&quot;&lt;/span&gt;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;ul class=&quot;pre-numbering&quot; style=&quot;box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);&quot;&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;1&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;2&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;3&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;4&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;5&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;6&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;7&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;8&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;9&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;10&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;11&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;pre-numbering&quot; style=&quot;box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);&quot;&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;1&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;2&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;3&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;4&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;5&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;6&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;7&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;8&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;9&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;10&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;11&lt;/li&gt;&lt;/ul&gt; 效果如图: 两者效果一样的,但是跟使用src不同的是,ImageButton的效果也跟着具体参数不同而改变了. 下面就说一下src和background的区别吧(ImageView和ImageButton通用): (1),src指定的是原图的大小,宽高设置成图片的原始尺寸,在分辨率不同的手机上,显示效果会不同,但不会进行拉伸;background会根据具体的宽高进行拉伸 注意:src指定的图片的宽高要是设置成超过其原始尺寸,比如图片原始像素是4848,但是宽高设置成100100,图片也是会被拉伸的 (2),src是图片的前景,background是背景,background是所有控件都有的属性,两者可以同时使用 (3),scaleType属性只有src才生效 6,点9图 &lt;code class=&quot;hljs perl has-numbering&quot; style=&quot;display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: &apos;Source Code Pro&apos;, monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;&quot;&gt;&lt;ImageView android:layout_width=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;150dp&quot;&lt;/span&gt; android:layout_height=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;150dp&quot;&lt;/span&gt; android:src=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot; style=&quot;color: rgb(102, 0, 102); box-sizing: border-box;&quot;&gt;@drawable&lt;/span&gt;/bg&quot;&lt;/span&gt;/&gt; &lt;ImageButton android:layout_width=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;150dp&quot;&lt;/span&gt; android:layout_height=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;150dp&quot;&lt;/span&gt; android:layout_marginTop=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;10dp&quot;&lt;/span&gt; android:background=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot; style=&quot;color: rgb(102, 0, 102); box-sizing: border-box;&quot;&gt;@null&lt;/span&gt;&quot;&lt;/span&gt; android:src=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot; style=&quot;color: rgb(102, 0, 102); box-sizing: border-box;&quot;&gt;@drawable&lt;/span&gt;/bg&quot;&lt;/span&gt;/&gt; &lt;ImageView android:layout_width=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;150dp&quot;&lt;/span&gt; android:layout_height=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;150dp&quot;&lt;/span&gt; android:layout_marginTop=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;10dp&quot;&lt;/span&gt; android:background=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot; style=&quot;color: rgb(102, 0, 102); box-sizing: border-box;&quot;&gt;@drawable&lt;/span&gt;/bg&quot;&lt;/span&gt;/&gt; &lt;ImageButton android:layout_width=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;150dp&quot;&lt;/span&gt; android:layout_height=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;150dp&quot;&lt;/span&gt; android:layout_marginTop=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;10dp&quot;&lt;/span&gt; android:background=&lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(0, 136, 0); box-sizing: border-box;&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot; style=&quot;color: rgb(102, 0, 102); box-sizing: border-box;&quot;&gt;@drawable&lt;/span&gt;/bg&quot;&lt;/span&gt;/&gt;&lt;/code&gt;&lt;ul class=&quot;pre-numbering&quot; style=&quot;box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);&quot;&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;1&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;2&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;3&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;4&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;5&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;6&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;7&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;8&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;9&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;10&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;11&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;12&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;13&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;14&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;15&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;16&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;17&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;18&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;19&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;20&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;21&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;22&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;23&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;pre-numbering&quot; style=&quot;box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);&quot;&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;1&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;2&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;3&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;4&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;5&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;6&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;7&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;8&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;9&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;10&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;11&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;12&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;13&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;14&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;15&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;16&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;17&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;18&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;19&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;20&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;21&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;22&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; padding: 0px 5px;&quot;&gt;23&lt;/li&gt;&lt;/ul&gt; 效果如下:","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"CheckBox多选框","slug":"CheckBox","date":"2016-07-09T07:23:36.000Z","updated":"2018-03-23T07:25:09.297Z","comments":true,"path":"2016/07/09/CheckBox/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2016/07/09/CheckBox/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（https://blog.csdn.net/weimeig/article/details/79662379），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的Android基础薄弱的问题，决定出一套Android基础教程，帮助大家复习，巩固Android基础，今天要讲的是Android中的CheckBox多选框。 布局文件 activity_checkbo.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;请选择爱好：&quot; android:layout_weight=&quot;1&quot;/&gt; &lt;CheckBox android:id=&quot;@+id/dianjing_cb&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;电竞&quot; /&gt; &lt;!-- android:checked=&quot;true&quot; 设置默认为选定状态 --&gt; &lt;CheckBox android:id=&quot;@+id/lvyou_cb&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;旅游&quot; android:layout_weight=&quot;1&quot;/&gt; &lt;CheckBox android:id=&quot;@+id/dushu_cb&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;读书&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:id=&quot;@+id/all_btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;全选&quot;/&gt; &lt;Button android:id=&quot;@+id/notall_btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;全不选&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:id=&quot;@+id/getResult_btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;获取内容&quot;/&gt; &lt;TextView android:id=&quot;@+id/showResult_tv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;此文本框用于显示结果&quot;/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; Java代码 import android.graphics.Color; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.CheckBox; import android.widget.CompoundButton; import android.widget.TextView; import android.widget.Toast; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { private CheckBox dianJing,lvYou,duShu; private CheckBoxListener checkBoxListener; private ButtonListener btnButtonListener; private Button all,notall,getResult; private TextView showResult; private List&lt;String&gt; lists; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_checkbo); initView(); initData(); setListener(); } private void initView(){ /** * findViewById初始化控件 */ dianJing = findViewById(R.id.dianjing_cb); lvYou = findViewById(R.id.lvyou_cb); duShu = findViewById(R.id.dushu_cb); all = findViewById(R.id.all_btn); notall = findViewById(R.id.notall_btn); showResult = findViewById(R.id.showResult_tv); getResult = findViewById(R.id.getResult_btn); } private void setListener(){ /** * 绑定监听器 */ checkBoxListener = new CheckBoxListener(); btnButtonListener = new ButtonListener(); duShu.setOnCheckedChangeListener(checkBoxListener); lvYou.setOnCheckedChangeListener(checkBoxListener); dianJing.setOnCheckedChangeListener(checkBoxListener); all.setOnClickListener(btnButtonListener); notall.setOnClickListener(btnButtonListener); getResult.setOnClickListener(btnButtonListener); } class CheckBoxListener implements CompoundButton.OnCheckedChangeListener{ /** * 找到ID * @param buttonView * @param isChecked */ @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { CheckBox checkBox = (CheckBox) buttonView; switch (checkBox.getId()){ case R.id.dianjing_cb: if(isChecked){ Toast.makeText(MainActivity.this,&quot;少玩游戏多谢代码！&quot;+isChecked,1000).show(); dianJing.setTextColor(Color.RED); }else{ Toast.makeText(MainActivity.this,&quot;电竞&quot; +isChecked,1000).show(); dianJing.setTextColor(Color.BLACK); } break; case R.id.lvyou_cb: Toast.makeText(MainActivity.this,&quot;旅游&quot; +isChecked,1000).show(); break; case R.id.dushu_cb: Toast.makeText(MainActivity.this,&quot;读书&quot; +isChecked,1000).show(); break; } } } private void initData(){ /** * 获取生成集合对象 */ lists = new ArrayList&lt;String&gt;(); } class ButtonListener implements View.OnClickListener{ @Override public void onClick(View v) { switch (v.getId()){ case R.id.all_btn: dianJing.setChecked(true); lvYou.setChecked(true); duShu.setChecked(true); break; case R.id.notall_btn: dianJing.setChecked(false); lvYou.setChecked(false); duShu.setChecked(false); break; case R.id.getResult_btn: if(dianJing.isChecked()){ lists.add(dianJing.getText().toString()); } if(lvYou.isChecked()){ lists.add(lvYou.getText().toString()); } if(duShu.isChecked()){ lists.add(duShu.getText().toString()); } showResult.setText(lists.toString()); lists.clear(); break; } } } }","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"RadioGroup和RadioButton单选框","slug":"RadioGroupRadioBtn","date":"2016-07-08T07:21:33.000Z","updated":"2018-03-23T07:23:05.440Z","comments":true,"path":"2016/07/08/RadioGroupRadioBtn/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2016/07/08/RadioGroupRadioBtn/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（https://blog.csdn.net/weimeig/article/details/79662567），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的Android基础薄弱的问题，决定出一套Android基础教程，帮助大家复习，巩固Android基础，今天要讲的是Android中的RadioGroup和RadioButton单选框。 布局文件 activity_radiobutton.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!-- 1、RadioButton是圆形单选 2、RadioRroup是可以容纳多个RadioButton的容器 *在RadioGroup中的RadioButton控件可以有多个，但同时有且仅有一个可以被选中 --&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;请选择性别&quot;/&gt; &lt;RadioGroup android:id=&quot;@+id/sex_rg&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;RadioButton android:id=&quot;@+id/Male_rb&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;男&quot;/&gt; &lt;RadioButton android:id=&quot;@+id/FeMale_rb&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;女&quot;/&gt; &lt;/RadioGroup&gt; &lt;/LinearLayout&gt; Java代码 import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.RadioButton; import android.widget.RadioGroup; public class MainActivity extends AppCompatActivity { private RadioGroup rg; private RadioButton Male_rb,FeMale_rb; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_radiobutton); initView(); rg.setOnCheckedChangeListener(new MyRadioButtonListener());//绑定监听器 } private void initView() { rg = findViewById(R.id.sex_rg); Male_rb = findViewById(R.id.Male_rb); FeMale_rb =findViewById(R.id.FeMale_rb); } class MyRadioButtonListener implements RadioGroup.OnCheckedChangeListener{ @Override public void onCheckedChanged(RadioGroup group, int checkedId) { //选中状态改变时被触发 switch (checkedId){ case R.id.Male_rb: //当用户选择女性时 Log.i(&quot;sex&quot;,&quot;当前用户选择&quot; +Male_rb.getText().toString()); break; case R.id.FeMale_rb: //当用户选择男性时 Log.i(&quot;sex&quot;,&quot;当前用户选择&quot; +FeMale_rb.getText().toString()); break; } } } }","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"ToggleButton开关按钮","slug":"ToggleButton","date":"2016-07-06T07:19:45.000Z","updated":"2018-03-23T07:20:44.213Z","comments":true,"path":"2016/07/06/ToggleButton/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2016/07/06/ToggleButton/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。转帖请注明本文出自weimeig的博客（https://blog.csdn.net/weimeig/article/details/79663037），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的Android基础薄弱的问题，决定出一套Android基础教程，帮助大家复习，巩固Android基础，今天要讲的是Android中的ToggleButton开关按钮。 布局文件 activity_togglebutton.xm &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;你今天开心吗？&quot;/&gt; &lt;ImageView android:id=&quot;@+id/happy_iv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_launcher&quot;/&gt; &lt;ToggleButton android:id=&quot;@+id/tb&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:checked=&quot;true&quot; android:textOff=&quot;不开心&quot; android:textOn=&quot;开心&quot;/&gt; &lt;/LinearLayout&gt; Java文件 import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.ImageView; import android.widget.RadioButton; import android.widget.RadioGroup; import android.widget.TextView; import android.widget.Toast; import android.widget.ToggleButton; public class MainActivity extends AppCompatActivity { private ToggleButton mToggleButton; private TextView mTextView; private ImageView mImageView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_togglebutton); mImageView = findViewById(R.id.happy_iv); mToggleButton = findViewById(R.id.tb); mToggleButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if(mToggleButton.isChecked()){ Toast.makeText(MainActivity.this,mToggleButton.getText().toString(),1000).show(); mImageView.setImageResource(R.mipmap.ic_launcher);//设置ImageView控件图片所显示的内容 }else{ Toast.makeText(MainActivity.this,mToggleButton.getText().toString(),1000).show(); mImageView.setImageResource(R.drawable.ic_launcher_foreground);//设置ImageView控件图片所显示的内容 } } }); } }","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"SeekerBar、ProgressBar、RatingBar进度条的基本使用","slug":"SeekRatingProBar","date":"2016-07-05T07:17:53.000Z","updated":"2018-03-23T07:19:20.606Z","comments":true,"path":"2016/07/05/SeekRatingProBar/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2016/07/05/SeekRatingProBar/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（https://blog.csdn.net/weimeig/article/details/79665512），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的Android基础薄弱的问题，决定出一套Android基础教程，帮助大家复习，巩固Android基础，今天要讲的是Android中的SeekerBar、ProgressBar、RatingBar进度条的基本使用。 SeekerBar拖拽进度条 activity_seekbar.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;SeekBar android:id=&quot;@+id/seekbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/LinearLayout&gt; Java代码 import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.SeekBar; public class MainActivity extends AppCompatActivity { private SeekBar seekBar; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_seekbar); seekBar = findViewById(R.id.seekbar); seekBar.setMax(100);//设置最大进度值 seekBar.setProgress(30);//设置当前进度 seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) { //将在结束拖拽进度条时被触发 /** * 将在进度发生变化时被触发 * 1、当前绑定的seekBar对象 * 2、当前进度数值 * 3、是否为用户手动触发 */ Log.i(&quot;progress&quot;,seekBar.getProgress() + &quot;&quot;); } @Override public void onStartTrackingTouch(SeekBar seekBar) { //将在开始拖拽进度条时被触发 Log.i(&quot;progress&quot;,seekBar.getProgress() + &quot;&quot;); } @Override public void onStopTrackingTouch(SeekBar seekBar) { //将在结束拖拽进度条时被触发 Log.i(&quot;progress&quot;,seekBar.getProgress() + &quot;&quot;); } }); } } ProgressBar圆形进度条 activity_progressbar.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;默认圆形&quot;/&gt; &lt;ProgressBar android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;超大号圆形&quot;/&gt; &lt;ProgressBar android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; style=&quot;?android:attr/progressBarStyleLarge&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;小号圆形&quot;/&gt; &lt;ProgressBar android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; style=&quot;?android:attr/progressBarStyleSmall&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;水平方向--长条形&quot;/&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar_pb&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; android:max=&quot;100&quot; android:progress=&quot;30&quot; android:secondaryProgress=&quot;50&quot;/&gt; &lt;!-- max 最大进度 progress 当前进度 secondaryProgress 次要进度 --&gt; &lt;Button android:id=&quot;@+id/btn_01&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;增加第一进度&quot;/&gt; &lt;Button android:id=&quot;@+id/btn_02&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;增加第二进度&quot;/&gt; &lt;/LinearLayout&gt; Java代码 import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.ProgressBar; import android.widget.SeekBar; public class MainActivity extends AppCompatActivity { private ProgressBar mProgressBar; private Button btn01,btn02; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_progressbar); initView(); mProgressBar.setMax(100); mProgressBar.setProgress(30); mProgressBar.setSecondaryProgress(40); ButtonListener mButtonListener = new ButtonListener(); btn01.setOnClickListener(mButtonListener); btn02.setOnClickListener(mButtonListener); } private void initView() { mProgressBar = (ProgressBar) findViewById(R.id.progressBar_pb); btn01 = (Button)findViewById(R.id.btn_01); btn02 =(Button) findViewById(R.id.btn_02); } class ButtonListener implements View.OnClickListener{ @Override public void onClick(View v) { switch (v.getId()){ case R.id.btn_01: mProgressBar.incrementProgressBy(20);//累加首要进度条的进度值 break; case R.id.btn_02: mProgressBar.incrementSecondaryProgressBy(40);//累加次要进度条的进度值 break; } } } } RatingBar星形进度条 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;RatingBar android:id=&quot;@+id/ratingBar_rb&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:isIndicator=&quot;false&quot; android:numStars=&quot;5&quot; android:stepSize=&quot;0.5&quot;/&gt; &lt;!-- isIndicator指示器，ture不允许用户手动改动 stepSize设置0.5时，手动可选半颗星，numStars星星总数 --&gt; &lt;/RelativeLayout&gt; Java代码 import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.ProgressBar; import android.widget.RatingBar; import android.widget.SeekBar; public class MainActivity extends AppCompatActivity { private RatingBar mRatingBar; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_ratingbar); mRatingBar = findViewById(R.id.ratingBar_rb); mRatingBar.setOnRatingBarChangeListener(new RatingBar.OnRatingBarChangeListener() { @Override public void onRatingChanged(RatingBar ratingBar, float rating, boolean fromUser) { /** * 1、当前绑定的ratingBar * 2、当前ratingBar评分的进度 * 3、是否由用户评分 */ System.out.println(&quot;当前ratingBar：评分&quot; + rating +&quot;是否来自用户&quot; + fromUser +&quot;每次评分的刻度&quot; +ratingBar.getStepSize()); } }); } }","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"DatePicker和TimePicker时间和日期选择器","slug":"DateTimePicker","date":"2016-07-03T07:16:11.000Z","updated":"2018-03-23T07:17:05.419Z","comments":true,"path":"2016/07/03/DateTimePicker/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2016/07/03/DateTimePicker/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（https://blog.csdn.net/weimeig/article/details/79666458），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的Android基础薄弱的问题，决定出一套Android基础教程，帮助大家复习，巩固Android基础，今天要讲的是Android中的DatePicker和TimePicker时间和日期选择器。 xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TimePicker android:id=&quot;@+id/timePicker_tp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;/TimePicker&gt; &lt;DatePicker android:id=&quot;@+id/datePicker_tp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;/DatePicker&gt; &lt;TextView android:id=&quot;@+id/textView_tv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;显示当前日期&quot;/&gt; &lt;/LinearLayout&gt; Java代码 import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.widget.DatePicker; import android.widget.TextView; import android.widget.TimePicker; import java.util.Calendar; public class MainActivity extends AppCompatActivity { private TimePicker mTimePicker; private DatePicker mDatePicker; private TextView mTextView; private int Year,Month,Day,Hour,Minute; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); getCurrentTime(); } private void setPicker(){ //设置时间选择器为24小时制 mTimePicker.setIs24HourView(true); //设置时间选择器为当前时间 mTimePicker.setCurrentHour(Hour);//小时 mTimePicker.setCurrentMinute(Minute);//分钟 mTimePicker.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() { @Override public void onTimeChanged(TimePicker view, int hourOfDay, int minute) { //TimePicker 对象 hourOfDay 小时 minute 分钟 //当时间选择器发生改变时触发 System.out.println(&quot;From TimePicker:&quot; +hourOfDay + &quot;:&quot; +minute); } }); mDatePicker.init(Year, Month, Day, new DatePicker.OnDateChangedListener() { @Override public void onDateChanged(DatePicker view, int year, int monthOfYear, int dayOfMonth) { //当日期选择器发生改变时触发 System.out.println(&quot;From DatePicker:&quot; + year + &quot;/&quot; +(monthOfYear+1) +&quot;/&quot; +dayOfMonth);//国外计时方法月份从0开始算,因此要在月份后面+1 } }); } private void getCurrentTime() { //获取系统当前时间 Calendar calendar = Calendar.getInstance(); Year = calendar.get(Calendar.YEAR); Month = calendar.get(Calendar.MONTH); Day = calendar.get(Calendar.DAY_OF_MONTH); Hour = calendar.get(Calendar.HOUR); Minute = calendar.get(Calendar.MINUTE); } private void initView() { mTimePicker = (TimePicker) findViewById(R.id.timePicker_tp); mDatePicker = (DatePicker) findViewById(R.id.datePicker_tp); mTextView = (TextView) findViewById(R.id.textView_tv); } }","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Android中LinearLayout布局的常用属性总结读书笔记","slug":"LinearLayout","date":"2016-07-02T07:08:06.000Z","updated":"2018-03-23T07:15:35.127Z","comments":true,"path":"2016/07/02/LinearLayout/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2016/07/02/LinearLayout/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（https://blog.csdn.net/weimeig/article/details/79667479），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的Android基础薄弱的问题，决定出一套Android基础教程，帮助大家复习，巩固Android基础，今天要讲的是Android中的Android中LinearLayout布局的常用属性总结读书笔记。 基本属性要求 &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;/LinearLayout android:orientation 决定是水平排列或是垂直排列 vertical 垂直排列 horizontal 水平排列 垂直排列 Button &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; /&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 2&quot; /&gt; &lt;/LinearLayout&gt; 水平排列 Button &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; /&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 2&quot; /&gt; &lt;/LinearLayout&gt; 重心设定 &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;left&quot;&gt; &lt;/LinearLayout&gt; android:gravity 设定框架的内容的放置方向 center 水平垂直皆置中 center_vertical 垂直置中 center_horizontal 水平置中 top 置顶 left 置左 bottom 置底 right 置右 水平、垂直置中 &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center_vertical&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center_horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; /&gt; &lt;/LinearLayout&gt; 透过 OR 运算子组合重心 &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;top|right&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;bottom|left&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center_vertical|center_horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; /&gt; &lt;/LinearLayout&gt; 比例分配 &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; android:layout_weight=&quot;1&quot;/&gt; &lt;/LinearLayout&gt; android:layout_weight 子元件或子框架的比重。 LinearLayout 下的子元件或子框架，才能设定这项属性。 等比例分配 &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; android:layout_weight=&quot;1&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 2&quot; android:layout_weight=&quot;1&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 3&quot; android:layout_weight=&quot;1&quot;/&gt; &lt;/LinearLayout&gt; 比重都是 1，所以大小相同。 非等比例分配 &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; android:layout_weight=&quot;.10&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 2&quot; android:layout_weight=&quot;.20&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 3&quot; android:layout_weight=&quot;.70&quot;/&gt; &lt;/LinearLayout&gt; 10 代表 0.10 20 代表 0.20 70 代表 0.70 合起来刚好是 1 ，作 100% 分配。","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"android布局中几个距离单位的区别：px、dp、sp","slug":"DistanceUnit","date":"2016-07-01T07:05:46.000Z","updated":"2018-03-23T07:15:23.466Z","comments":true,"path":"2016/07/01/DistanceUnit/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2016/07/01/DistanceUnit/","excerpt":"","text":"一、px 像素，我们经常说的400*800这种的就是像素，这个比较好理解。 二、dp 要理解dp，首先要先引入dpi这个概念，dpi全称是dots per inch，对角线每英寸的像素点的个数，所以，它的计算公式如下： 比如height和width即为长宽的像素，平方和即为对角线的像素个数，size即我们常说的5寸手机、4寸手机中的5和4，即对角线的长度。 显然，一样是5寸的手机，分辨率越高，dpi越高。 dp也叫dip，是device independent pixels。设备不依赖像素的一个单位。 定义在dpi=160的设备上的1px=1dp，所以px和dp的转换公式为：px = dp * (dpi/160) 这样一来，如图2-1，用了像素的单位之后，在不同的设备显示出了不同的效果；在图2-2中，用了dp作为单位之后，dp相同之后，在不同的设备里面，转成px之后是相等的，所以就不会出现图2-1的情况。(图片来源千峰Mars) 三、sp 全称是scaled pixels。这个主要是用于项目中的字体大小。使用sp作为单位，当用户通过手机设置修改手机字体的时候，sp为单位的字体也会跟着改变。 总结：Android项目中的控件大小主要是使用dp作为单位，字体大小主要是用sp作为单位。 但不是强制要求，比如有的需求是需要字体符合系统字体大小用sp，但有的需求可能需要字体用dp，这样更适合屏幕大小，建议根据自身需求选择，常用的字体大小主要是用sp作为单位。","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Android中EditText的常见属性","slug":"AndroidEditText","date":"2016-06-23T00:57:02.000Z","updated":"2018-03-23T12:54:08.805Z","comments":true,"path":"2016/06/23/AndroidEditText/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2016/06/23/AndroidEditText/","excerpt":"","text":"EditText介绍: EditText 在开发中也是经常用到的控件，也是一个比较必要的组件，可以说它是用户跟Android应用进行数据传输的窗户，比如实现一个登陆界面，需要用户输入账号密码，然后我们获取用户输入的内容，提交给服务器进行判断。 EditText实例:开发中常用的登录界面 首先我们来看布局文件:activity_main.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;EditText android:id=&quot;@+id/et_phone&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginRight=&quot;20dp&quot; android:background=&quot;@null&quot; android:inputType=&quot;number&quot; android:maxLength=&quot;11&quot; android:hint=&quot;请输入手机号&quot; android:drawablePadding=&quot;10dp&quot; android:padding=&quot;10dp&quot; android:drawableLeft=&quot;@mipmap/icon_phone&quot; android:drawableBottom=&quot;@drawable/shape_et_bottom_line&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;EditText android:id=&quot;@+id/et_password&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginRight=&quot;20dp&quot; android:layout_marginTop=&quot;10dp&quot; android:background=&quot;@null&quot; android:inputType=&quot;textPassword&quot; android:maxLength=&quot;16&quot; android:padding=&quot;10dp&quot; android:drawablePadding=&quot;10dp&quot; android:hint=&quot;请输入密码&quot; android:drawableBottom=&quot;@drawable/shape_et_bottom_line&quot; android:drawableLeft=&quot;@mipmap/icon_password&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_login&quot; style=&quot;@style/Widget.AppCompat.Button.Colored&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot; android:layout_marginTop=&quot;30dp&quot; android:text=&quot;登 录&quot; android:textColor=&quot;#ffffffff&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;/LinearLayout&gt; 运行效果图如下: 这两个输入框的用的的大部分属性都在上面的表格中了，我这里解决下没有说过的属性。android:background=”@null” 输入框无背景android:drawableBottom=”@drawable/shape_et_bottom_line” 底部引入一个shape布局文件，这个布局文件就是输入框的下划线。 shape_et_bottom_line.xml内容如下: &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot; &gt; &lt;solid android:color=&quot;#1E7EE3&quot; /&gt; &lt;size android:height=&quot;1dp&quot; android:width=&quot;500dp&quot;/&gt; &lt;/shape&gt; EditeText还有哪些功能？ 1.监听用户输入的内容.有这样一个场景，一个搜索框，只要用户输入了内容就去请求服务器，于是我们在Activity里面监听EditeText文本改变事件。 EditText etOne= (EditText) findViewById(R.id.et_phone); etOne.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { Log.i(&quot;Ansen&quot;,&quot;内容改变之前调用:&quot;+s); } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { Log.i(&quot;Ansen&quot;,&quot;内容改变，可以去告诉服务器:&quot;+s); } @Override public void afterTextChanged(Editable s) { Log.i(&quot;Ansen&quot;,&quot;内容改变之后调用:&quot;+s); } }); 首先我们通过id找到EditText控件，并且添加监听函数，内部内实现TextWatcher接口，重写三个方法。我们可以在onTextChanged方法中告诉服务器我要搜索的内容。","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Android中onClick按钮单击事件的四种常用写法读书笔记","slug":"OnClickListener","date":"2016-05-22T00:45:49.000Z","updated":"2018-03-21T18:49:53.627Z","comments":true,"path":"2016/05/22/OnClickListener/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2016/05/22/OnClickListener/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 Android中onClick按钮单击事件的四种常用写法读书笔记 XML文件 &lt;EditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:inputType=&quot;phone&quot; android:ems=&quot;10&quot; android:id=&quot;@+id/et_number&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentStart=&quot;true&quot; /&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/dial_number&quot; android:id=&quot;@+id/bt_dial&quot; android:layout_below=&quot;@id/et_number&quot; android:layout_alignRight=&quot;@id/et_number&quot; android:layout_alignEnd=&quot;@id/et_number&quot; /&gt; 第一种、匿名内部类： protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button bt_dial = (Button) findViewById(R.id.bt_dial); bt_dial.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { dialPhone(); } }); } 第二种、自定义单击事件监听类： protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); et_number = (EditText) MainActivity.this.findViewById(R.id.et_number); Button bt_dial = (Button) findViewById(R.id.bt_dial); bt_dial.setOnClickListener(new MyListener()); } private class MyListener implements View.OnClickListener { @Override public void onClick(View view) { dialPhone(); } } 第三种、Activity继承View.OnClickListener，由Activity实现OnClick(View view)方法，在OnClick(View view)方法中用switch-case对不同id代表的button进行相应的处理： public class MainActivity extends Activity implements View.OnClickListener { EditText et_number; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); et_number = (EditText) MainActivity.this.findViewById(R.id.et_number); Button bt_dial = (Button) findViewById(R.id.bt_dial); bt_dial.setOnClickListener(this); } public void onClick(View view) { switch (view.getId()){ case R.id.bt_dial: dialPhone(); break; default: break; } } } 第四种、在XML文件中显示指定按钮的onClick属性，这样点击按钮时会利用反射的方式调用对应Activity中的click()方法： &lt;Button android:onClick=&quot;dialPhoneMethod&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/dial_number&quot; android:id=&quot;@+id/bt_dial&quot; android:layout_below=&quot;@id/et_number&quot; android:layout_alignRight=&quot;@id/et_number&quot; android:layout_alignEnd=&quot;@id/et_number&quot; /&gt; public void dialPhoneMethod(View view){ dialPhone(); } private void dialPhone() { String number = et_number.getText().toString().trim(); if (TextUtils.isEmpty(number)){ Toast.makeText(this, &quot;电话号码不能为空&quot;, Toast.LENGTH_LONG).show(); return; } Intent intent = new Intent(); intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:&quot; + number)); startActivity(intent); } 总结：第四种写法整个代码中都不用声明button就可以实现button的单击事件。但通常不推荐这样使用，第三种方法是onClick最佳的的使用方式。按钮少的时候用匿名内部类会比较快，比如写demo测试的时候。","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Android中TextView的常见属性","slug":"AndroidTextView","date":"2016-05-12T00:49:07.000Z","updated":"2018-03-21T19:25:19.612Z","comments":true,"path":"2016/05/12/AndroidTextView/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2016/05/12/AndroidTextView/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79648351），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的Android基础薄弱的问题，决定出一套完整的Android基础教程，帮助大家复习，巩固Android基础，今天要讲的是Android中TestView的一些常见属性。 显示内容过长 EidtText和textview中内容过长的话自动换行，使用android：ellipsize与android：singleine可以解决，使只有一行。 EditText不支持marquee 用法如下： 在xml中 android:ellipsize = &quot;end&quot; 省略号在结尾 android:ellipsize = &quot;start&quot; 省略号在开头 android:ellipsize = &quot;middle&quot; 省略号在中间 android:ellipsize = &quot;marquee&quot; 跑马灯无限循环 android:singleline = &quot;true&quot; android:marqueeRepeatLimit=&quot;marquee_forever&quot; 跑马灯无限循环 当然也可以用代码语句 tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;END&quot;)); tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;START&quot;)); tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;MIDDLE&quot;)); tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;MARQUEE&quot;)); tv.setSingleLine(true); 另外，TextView中使用background属性，可以@color，设置背景颜色，也可以@一张图片资源的名字，作为背景图片 比如AdnroidStudio中的 android:background=&quot;@mipmap/ic_launcher&quot; 还可以通过的background的drawable属性，往文章的附件添加图片，比如登录界面可能用户名输入框的左边有个小图标，可以这样写 android:drawableLeft=&quot;@mipmap/ic_launcher&quot; 那么在文字的左侧将会被添加上一张图片 testSize属性可以设置文字的尺寸，sp是随系统的字体而改变大小，dp是随屏幕的大小决定字体的大小，根据实际需要决定，文字通常不用px，px是写死像素大小，不适合适配，通常很不美观 autoLink属性的引号中选择类型，比如选择email，那么文字中的email会实现连接的点击效果 android:autoLink=&quot;email&quot; testStyle属性设置字体的风格，可以有粗体、细体和斜体 android:textStyle=&quot;bold&quot; typeface属性设置文字字体的类型，可以有常规、无衬线字体、细体和等宽字体 android:typeface=&quot;monospace&quot;","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"JAVA中的泛型","slug":"Java-Genericity","date":"2015-05-17T10:53:37.000Z","updated":"2018-03-19T10:58:20.387Z","comments":true,"path":"2015/05/17/Java-Genericity/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/05/17/Java-Genericity/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79535182），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是JAVA中的泛型。 本篇文章基于http://blog.csdn.net/weimeig/article/details/79533661知识的基础上，请先学前面这篇文章。 泛型 集合中的元素，可以是任意类型的对象（对象的引用） 如果把某个对象放入集合，则会忽略他的类型，而把他当作Object处理 泛型则是规定了某个集合只可以存放特定类型的对象 会在编译期间进行类型检查 可以直接按指定类型获取集合元素 /** * 学生类 * @author Administrator * */ public class Student { private String id; private String name; private Set course; private Student(String id,String name){ this.id = id; this.name = name; this.course = new HashSet(); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Set getCourse() { return course; } public void setCourse(Set course) { this.course = course; } } /** * 课程类 * @author Administrator * */ public class Course { private String id; private String name; Course(){ } Course(String id,String name){ this.id=id; this.name=name; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } import java.util.ArrayList; import java.util.List; public class TestGeneric { /** * 带有泛型——Course,的List类型属性 */ public List&lt;Course&gt; courses; //&lt;&gt;内限制了数据的类型 //创建构造器实例化 public TestGeneric(){ //构造方法 this.courses = new ArrayList&lt;Course&gt;(); } /** * 测试添加 */ public void testAdd(){ Course cr1 = new Course(&quot;1&quot;,&quot;大学英语&quot;); courses.add(cr1); //泛型集合中，不能添加泛型规定的类型及其子类型以外的对象，否则会报错 // courses.add(&quot;能否添加一些奇怪的东西呢？&quot;); Course cr2 = new Course(&quot;2&quot;, &quot;Java基础&quot;); courses.add(cr2); } public void testForEach(){ for(Course cr:courses){//因为规定了是Course的类型，所以直接作为Course类型取出来，不再需要作为Object类型的转换。 System.out.println(cr.getId() + &quot;:&quot; +cr.getName()); } } public static void main(String[] args){ TestGeneric tg =new TestGeneric(); tg.testAdd(); tg.testForEach(); } } 泛型集合可以添加泛型的子类型的对象实例 创建ChildCourse类，继承Course类 public class ChildCourse extends Course {//ChildCourse继承了Course类型，如果Course类里已经添加了含参的构造器， //编译器将不会自动为他再添加一个隐式构造器，而子类又必须要调用父类的隐式构造器，因此会报错，所以需要在父类中手动定义一个的无参的隐式构造器 // 不添加属性让他默认继承父类的属性 } 在TestGeneric类中添加方法 /** * 泛型集合可以添加泛型的子类型的对象实例 * @param args */ public void testChild(){ ChildCourse ccr = new ChildCourse(); ccr.setId(&quot;3&quot;); ccr.setName(&quot;我是子类型的课程对象实例～～&quot;); courses.add(ccr); } main函数中调用 TestGeneric tg =new TestGeneric(); tg.testChild(); tg.testForEach(); 1、泛型集合中的限定类型，不能使用基本数据类型。2、可以通过使用包装类限定允许存入的基本数据类型 /** * 泛型不能使用基本类型 * @param args */ public void testBasicType(){ / List&lt;int&gt; list = new ArrayList&lt;int&gt;();//使用基本类型报错 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();//使用包装类 list.add(1);//将1转化为了基本类型的包装类Integer System.out.println(&quot;基本类型必须使用包装类作为泛型！&quot; + list.get(0)); } main函数中调用 TestGeneric tg =new TestGeneric(); tg.testBasicType();","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"JAVA中的集合框架（Map&HashMap）","slug":"Java-Map-HashMap","date":"2015-04-29T10:55:24.000Z","updated":"2018-03-19T11:05:48.726Z","comments":true,"path":"2015/04/29/Java-Map-HashMap/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/29/Java-Map-HashMap/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79575842），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是JAVA中的Map&amp;HashMap集合。 import java.util.HashSet; import java.util.Set; /** * 学生类 * @author Administrator * */ public class Student { private String id; private String name; private Set&lt;Course&gt; course; Student(String id,String name){ this.id = id; this.name = name; this.course = new HashSet&lt;Course&gt;(); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Set getCourse() { return course; } public void setCourse(Set course) { this.course = course; } public Student get(String stuId) { // TODO Auto-generated method stub return null; } } import java.util.HashMap; import java.util.Map; import java.util.Map.Entry; import java.util.Scanner; import java.util.Set; public class MapTest { /** * 用来承装学生类型对象 */ public Map&lt;String,Student&gt; students; /** * 在构造器中初始化student属性 */ public MapTest(){ this.students = new HashMap&lt;String, Student&gt;(); } /** * 测试添加：输入学生ID.判断时候被占用 * 若未被占用，则输入姓名，创建新学生对象，并且 * 添加到students中 * @param args */ public void testPut(){ //创建一个Scanner对象，用来获取输入的学生ID和姓名 Scanner console = new Scanner(System.in); int i = 0; while(i &lt; 3){ System.out.println(&quot;请输入学生ID：&quot;); String ID = console.next(); //提示输入学生姓名 Student st = students.get(ID); if(st == null){ //提示输入学生姓名 System.out.println(&quot;请输入学生姓名：&quot;); String name = console.next(); //创建新的学生对象 Student newStudent = new Student(ID,name); //通过调用students的put方法，添加ID-学生映射 students.put(ID, newStudent); System.out.println(&quot;成功添加学生：&quot; + students.get(ID).getName()); i++; }else{ System.out.println(&quot;该学生ID已被占用！&quot;); } } } /** * 测试Map的KeySet方法 * @param args */ public void testKeySet(){ //通过KeySet方法，返回Map中的所有&quot;键&quot;的Set集合 Set&lt;String&gt; KeySet = students.keySet(); //遍历KeySet，取得每一个键，再调用get方法取得每个键对于的value //取得student的容量 System.out.println(&quot;总共有&quot; + students.size() + &quot;个学生&quot;); for(String stuId:KeySet){ Student st = students.get(stuId); if(st!=null){ System.out.println(&quot;学生&quot; + st.getName()); } } } /** * 测试删除Map中的映射 * @param args */ public void testRemove(){ //获取从键盘输入的待删除学生ID字符串 Scanner console = new Scanner(System.in); while (true) { //提示输入待删除的学生的ID System.out.println(&quot;请输入要删除的学生ID&quot;); String ID =console.next(); //判断该ID是否有对应的学生对象 Student st = students.get(ID); if(st == null){ //提示输入的ID并不存在 System.out.println(&quot;该ID不存在&quot;); continue; } students.remove(ID); System.out.println(&quot;成功删除学生：&quot; + st.getName()); break; } } /** * 通过entrySet方法来遍历Map * @param args */ public void testEntrySet(){ //通过enterSet方法，返回Map中所有键值对的集合，KeySet只是返回所有键的集合，EntrySet是返回所有键值对的集合 // Set&lt;Entry&gt; entrySet = student.entrySet();//会报错，因为entrySet返回的是entry的集合，而entry本身是带有和定义Map类型的泛型一样的泛型 Set&lt;Entry&lt;String,Student&gt;&gt; entrySet = students.entrySet();//所以要为他定义和当时定义的Map类型一样的数据类型 for(Entry&lt;String,Student&gt; entry:entrySet){ System.out.println(&quot;取得键：&quot; + entry.getKey()); System.out.println(&quot;对应的值为：&quot; + entry.getValue().getName()); } } /** * 利用put方法修改Map中的已有映射 * @param args */ public void testModify(){ //提示输入要修改的学生ID System.out.println(&quot;请输入要修改的学生ID：&quot;); //创建一个Scanner对象，去获取从键盘上输入的学生ID字符串 Scanner console = new Scanner(System.in); while (true) { //取得从键盘输入的学生ID String stuId = console.next(); //从student中查找该学生ID对应的学生对象 Student student = students.get(stuId); if(student == null){ System.out.println(&quot;该ID不存在！请重新输入！&quot;); continue; } //提示当前对应的学生对象的姓名 System.out.println(&quot;当前该学生ID，所对应的学生为&quot; + student.getName()); //提示输入新的学生姓名，来修改已有的映射 System.out.println(&quot;请输入新的学生姓名：&quot;); String name = console.next(); Student newStudent = new Student(stuId, name); students.put(stuId, newStudent); System.out.println(&quot;修改成功！&quot;); break; } } public static void main(String[] args){ MapTest mt =new MapTest(); mt.testPut();//增加 mt.testKeySet();//遍历所有的键 // mt.testRemove();//删除 // mt.testEntrySet();//遍历所有的键和值 mt.testModify();//修改 mt.testEntrySet();//遍历所有的键和值 } }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"JAVA中的集合框架（Set）","slug":"Java-HashSet","date":"2015-04-28T10:55:09.000Z","updated":"2018-03-19T11:01:15.788Z","comments":true,"path":"2015/04/28/Java-HashSet/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/28/Java-HashSet/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79535273），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是JAVA中的Set集合。 ArrayList是有序的集合，而Set是无序的集合 有序的集合ArrayList中可以添加多个相同对象（的引用） 而Set中，添加某个对象，无论添加多少次， 最终只会保留一个该对象（的引用） 并且，保留的是第一次添加的那一个 import java.util.HashSet; import java.util.Set; /** * 学生类 * @author Administrator * */ public class Student { private String id; private String name; private Set&lt;Course&gt; course; Student(String id,String name){ this.id = id; this.name = name; this.course = new HashSet&lt;Course&gt;(); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Set getCourse() { return course; } public void setCourse(Set course) { this.course = course; } } /** * 课程类 * @author Administrator * */ public class Course { private String id; private String name; Course(){ } Course(String id,String name){ this.id=id; this.name=name; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Scanner; public class SetTest { public List&lt;Course&gt; coursesToSelect; public SetTest(){ this.coursesToSelect = new ArrayList&lt;Course&gt;(); } /** * 用于往coursesToSelect中添加备选课程 */ public void testAdd(){ Course cr1 = new Course(&quot;1&quot;,&quot;数据结构&quot;);//new一个Course类的数据类型 coursesToSelect.add(cr1);//所为一条数据插入List中 Course temp = (Course)coursesToSelect.get(0);//获取LIst中的第一条数据\\ Course cr2 = new Course(&quot;2&quot;,&quot;C语言&quot;); coursesToSelect.add(0, cr2); //两个参数的add方法，选择插入元素的位置 Course temp2 = (Course) coursesToSelect.get(0);//将元素插入到第一条,对象存入集合都变成Object类型，取出时需要类型转换 Course[] course = {new Course(&quot;3&quot;,&quot;离散数学&quot;), new Course(&quot;4&quot;,&quot;汇编语言&quot;)}; coursesToSelect.addAll(Arrays.asList(course)); //添加数组用addAll Course temp3 = (Course) coursesToSelect.get(2); Course temp4 = (Course) coursesToSelect.get(3); //按位置插入 Course[] course2 = {new Course(&quot;5&quot;,&quot;高等数学&quot;),new Course(&quot;6&quot;,&quot;大学英语&quot;)}; coursesToSelect.addAll(2, Arrays.asList(course2)); Course temp5 = (Course)coursesToSelect.get(2); Course temp6 = (Course)coursesToSelect.get(3); } /** * 通过for each方法访问集合元素 * 迭代器的简便写法 * @param args */ public void testForEach(){ System.out.println(&quot;有如下课程可选（通过for each访问）：&quot;); for(Object obj:coursesToSelect){//去遍历coursesToSelect集合中的每一个元素，把它取出来作为Object的一个变量 //（当一个元素存入到集合中的时候，他的类型是被忽略了的，集合只是拿他当Object用），当取出来的时候也是一个Object，因此 Course cr =(Course)obj;//当他取出来后，需要做强转 System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } public static void main(String []args){ SetTest st =new SetTest(); st.testAdd(); st.testForEach(); //创建一个学生对象 Student student = new Student(&quot;1&quot;,&quot;小明&quot;); System.out.println(&quot;欢迎学生：&quot; + student.getName() + &quot;选课！&quot;); //创建一个Scanner对象，用来接收从键盘输入的课程ID Scanner console = new Scanner(System.in); for(int i=0;i&lt;3;i++){ System.out.println(&quot;请输入课程ID&quot;); String courseId = console.next(); for(Course cr:st.coursesToSelect){ if(cr.getId().equals(courseId)){ student.getCourse().add(cr); // student.getCourse().add(cr); /** * Set中，添加某个对象，无论添加多少次， * 最终只会保留一个该对象（的引用） * 并且，保留的是第一次添加的那一个 */ // student.getCourse().add(null);Set中是允许添加null空对象的 } } } st.testForEachForSet(student); } public void testForEachForSet(Student student){ //打印输出，学生所选的课程！ System.out.println(&quot;共选择了&quot; + student.getCourse().size() + &quot;门课程&quot;); for(Object obj : student.getCourse()){ Course cr = (Course)obj; System.out.println(&quot;选择了课程：&quot; + cr.getId() + &quot;:&quot; +cr.getName()); } } }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"多线程的经典案例(生产消费问题)","slug":"MiltiCaseProduConsum","date":"2015-04-27T10:45:21.000Z","updated":"2018-03-19T10:52:23.469Z","comments":true,"path":"2015/04/27/MiltiCaseProduConsum/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/27/MiltiCaseProduConsum/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 多线程的经典案例(生产消费问题) 未完待续。。","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"多线程","slug":"Multithreading","date":"2015-04-23T10:18:36.000Z","updated":"2018-03-21T04:10:51.810Z","comments":true,"path":"2015/04/23/Multithreading/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/23/Multithreading/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79510581），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是多线程。 创建线程的第一种方法，创建线程的类。 class Xc extends Thread{//创建线程所需要继承的类 public void run(){//run方法是覆盖的父类方法 for(int i=0;i&lt;100;i++){ System.out.println(&quot;子线程&quot;); } } } public class XianCheng { public static void main(String [] args){ new Xc().start();//谁调Start方法，就会去自动调用run方法 for(int i=0;i&lt;100;i++){ System.out.println(&quot;主线程&quot;); } } } 创建线程的第二种方法，实现线程的接口。 class Xc2 implements Runnable{ public void run(){ for(int i=0;i&lt;100;i++){ System.out.println(&quot;子线程&quot;); } } } public class XianCheng { public static void main(String [] args){ new Thread(new Xc2()).start(); for(int i=0;i&lt;100;i++){ System.out.println(&quot;主线程&quot;); } } } 创建线程的第三种方法，简约写法。 public class XianCheng { public static void main(String [] args){ new Thread(){ public void run(){ for(int i=0;i&lt;100;i++){ System.out.println(&quot;子线程&quot;); } } }.start(); for(int i=0;i&lt;100;i++){ System.out.println(&quot;主线程&quot;); } } } 创建线程的第四种方法，简约写法。 public class XianCheng { public static void main(String [] args){ new Runnable() { public void run() { for(int i=0;i&lt;30;i++){ System.out.println(&quot;我是子线程！！！&quot;); } } }.run(); for(int i=0;i&lt;30;i++){ System.out.println(&quot;主线程&quot;); } } } 观察线程的竞争 class Xc3 extends Thread{ public void run(){ System.out.println(Thread.currentThread().getName()+&quot;线程在运行&quot;); } } public class XianCheng { public static void main(String [] args){ Xc3 xc3 = new Xc3(); xc3.setName(&quot;线程3&quot;); xc3.start(); Xc3 xc31 = new Xc3(); xc31.setName(&quot;线程2&quot;); xc31.start(); Xc3 xc32 = new Xc3(); xc32.setName(&quot;线程3&quot;); xc32.start(); System.out.println(Thread.currentThread().getName()+&quot;线程在运行&quot;); } } 线程的优先级 static int MAX_PRIORITY = 10;//线程可以具有的最高优先级（执行概率最高） static int MIN_PRIORITY = 1; //线程可以具有的最低优先级（执行概率最低） static int NORM_PRIORITY = 5；//分配给线程的默认优先级 写法（1） class Xc extends Thread{ public void run(){ System.out.println(&quot;线程1在运行&quot;); } } public class XianCheng { public static void main(String [] args){ Xc xc = new Xc();//线程默认优先级是5 xc.setPriority(Thread.NORM_PRIORITY + 3);//数字越大优先级越高 xc.start(); new Thread(){ public void run(){ System.out.println(&quot;第二个线程正在被执行&quot;); } }.start(); } } 写法（2） public class XianCheng { public static void main(String [] args){ new Thread(){ public void run(){//线程默认优先级是5 setPriority(Thread.NORM_PRIORITY + 3);//数字越大优先级越高 System.out.println(&quot;第1个线程&quot;); } }.start(); new Thread(){ public void run(){ System.out.println(&quot;第二个线程正在被执行&quot;); } }.start(); } } 线程的睡眠 public class XianCheng { public static void main(String [] args){ new Thread(){ public void run(){ for(int i=0;i&lt;10;i++){ System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); try { Thread.sleep(1000);//1000毫秒等于一秒 } catch (Exception e) { // TODO: handle exception } } } }.start(); } } 线程的抛异常问题，举例 都是会报错的，因为用throws抛异常的时候，如果向主调处抛异常的方法是从父类继承的或者是从接口实现的那么，覆盖父类的方法或实现接口方法时，如果父类中的原方法或接口中的原抽象方法没有抛异常，则子类覆盖父类的方法或实现接口的方法也不能抛异常。 class Yy implements Runnable{ public void run() throws Exception { } } class Xx extends Thread{ public void run() throws Exception { } } 当出现这种情况只能try…catch，大不了catch中什么都不写。 线程的让步 public class XianCheng { public static void main(String [] args){ new Thread(){ public void run(){ setName(&quot;线程一：&quot;); for(int i=1;i&lt;=30;i++){ System.out.println(Thread.currentThread().getName() + i); } } }.start(); new Thread(){ public void run(){ setName(&quot;线程二：&quot;); for(int i=1;i&lt;=30;i++){ System.out.println(Thread.currentThread().getName() + i); if(i%5==0){ Thread.yield(); //线程让步出去让其他线程先执行，再次执行时，从让步的这个位置重新执行。 } } } }.start(); } } 线程的阻塞 class Xc implements Runnable{ public void run(){ for(int i=0;i&lt;30;i++){ System.out.println(&quot;子线程&quot; + i); } } } public class XianCheng { public static void main(String [] args){ Thread xc = new Thread(new Xc()); xc.start(); try { xc.join();//阻塞时将当前线程暂停，直至调用join函数所对应的线程执行完毕，才继续执行程序。 //也就是说，当执行到这里，当前执行线程就暂停了，而去执行join所对应的xc这个线程，直到xc这个线程执行完毕才回来，此时线程们重新竞争CPU。 } catch (Exception e) { // TODO: handle exception } for(int i=0;i&lt;30;i++){ System.out.println(&quot;主线程&quot; + i); } } }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"接口","slug":"Interface","date":"2015-04-20T10:16:45.000Z","updated":"2018-03-21T04:10:57.138Z","comments":true,"path":"2015/04/20/Interface/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/20/Interface/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79501228），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是接口。 /** *接口：初步理解，接口是一个特殊的抽象类，当抽象类中全部是抽象方法时 *可以通过接口的形式来体现。 *class 用于定义类 *interface 用于定义接口 * * 接口中成员的格式： * 1.public static final String NAME=&quot;小李&quot;;//全局常量 * 2.public abstract void show();//抽象方法 * * 注意： * 1.接口中只能出现public 访问修饰符 * 2.接口不可以创建对象，因为里面有抽象方法，需要被子类实现， * 子类对接口中的所有抽象方法实现后，子类才能够实例化，否则 * 子类就是一个抽象类 * * 关系： * 类与类之间：继承关系 * 接口与类之间：实现关系 * 接口与接口之间：继承关系 * 接口与接口之间：不具备实现关系 */ interface smoket{ public static final String NAME=&quot;小李&quot;; public abstract void show(); } interface Game{ //inrerface Game extends Smoket{ //这句实现Game接口等同于实现了Game与Smoket //两个接口，需要实现两个的方法 public abstract void computerGame(); } class Student implements smoket,Game{ @Override public void show() { // TODO Auto-generated method stub System.out.println(&quot;吸烟&quot;); } @Override public void computerGame() { // TODO Auto-generated method stub System.out.println(&quot;游戏&quot;); } } public class jiekou { public static void main(String[] args){ Student s=new Student(); s.show(); s.computerGame(); } }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"多线程的经典案例(卖票问题)","slug":"MultiCaseTicket","date":"2015-04-16T10:40:16.000Z","updated":"2018-03-19T10:52:11.549Z","comments":true,"path":"2015/04/16/MultiCaseTicket/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/16/MultiCaseTicket/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79512965），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是多线程的经典案例。 卖票问题 class Xc implements Runnable{ public int chepiao = 100; public void run(){ while (true) { if(chepiao&gt;0){ System.out.println(&quot;第&quot; + Thread.currentThread().getName() + &quot;个车站正在卖出第&quot; + (101-chepiao) + &quot;张车票&quot;); --chepiao; }else{ break; } } } } public class XianCheng { public static void main(String [] args){ Thread Xc1 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc1.start(); Thread Xc2 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc2.start(); } } 通过代码，我们不难发现，在运行的过程中出现了错误，因为Xc1和Xc2各自都生成了100张车票，而车票没有共享，此时，我们需要将车票定义为静态变量，使得两线程在竞争售票的过程中，共享车票，于是，将常量定义为静态常量，用static修饰： public static int chepiao = 100; class Xc implements Runnable{ public static int chepiao = 100; public void run(){ while (true) { if(chepiao&gt;0){ System.out.println(&quot;第&quot; + Thread.currentThread().getName() + &quot;个车站正在卖出第&quot; + (101-chepiao) + &quot;张车票&quot;); --chepiao; }else{ break; } } } } public class XianCheng { public static void main(String [] args){ Thread Xc1 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc1.start(); Thread Xc2 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc2.start(); } } 但是很快的，我们又发现了新问题，因为线程在竞争的过程中，CPU的切换是非常快的，可能线程1正好执行完–maipiao的时候，线程已经切换到了线程2，此时–maipiao又再执行了一次，导致跳过了一张票没有卖出，或者，当线程1恰好正好将要执行–maipiao但还没执行的时候，线程已经切换到了线程2，此时因为线程1并没有进行–maipiao操作，线程2卖出了重复的同一张票以后，才执行了–maipiao，导致出现了同一张票重复销售的情况。 此时，我们需要引入线程锁的概念，以解决线程的同步问题。 第一种写法： class Xc implements Runnable{ public static int chepiao = 100; //synchronized的作用是，让它所管辖的代码部分，要么全部执行完，要么全部不执行，synchronized既可修饰代码块，又可以修饰函数 // 如果是锁整个方法，可以在方法内加锁，表达上比如public synchronized void run(){，但对于此案例，是两个线程之间竞争售票，因此不适宜锁起来整个方法 //如果synchronized是锁起来整个方法的，synchronized修饰函数不需要传入字符串参数，相当于默认是this public void run(){ while (true) { synchronized (&quot; &quot;) {//在需要加锁保证完整运行的代码块旁边加上synchronized (&quot; &quot;){}包裹代码，即可锁起来该部分代码，()内的字符串随意定义 if(chepiao&gt;0){ System.out.println(&quot;第&quot; + Thread.currentThread().getName() + &quot;个车站正在卖出第&quot; + (101-chepiao) + &quot;张车票&quot;); --chepiao; }else{ break; } } } } } public class XianCheng { public static void main(String [] args){ Thread Xc1 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc1.start(); Thread Xc2 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc2.start(); } } 第二种写法： class Xc implements Runnable{ public static int chepiao = 100; public static String str = new String(&quot;weimeig&quot;);//提取出来提高可维护性，同时定义为static静态变量，使得str是公共的 //如果不定义成static静态，则两个线程各自有各自的str，那么大家竞争的就不是同一个资源 public void run(){ while (true) { synchronized (str) {//若不定义为static静态，则两个线程的str是线程自己的，而不是公共的，因为这种写法，初始化的str写在了锁的外面 if(chepiao&gt;0){ System.out.println(&quot;第&quot; + Thread.currentThread().getName() + &quot;个车站正在卖出第&quot; + (101-chepiao) + &quot;张车票&quot;); --chepiao; }else{ break; } } } } } public class XianCheng { public static void main(String [] args){ Thread Xc1 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc1.start(); Thread Xc2 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc2.start(); } }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"JAVA中的集合框架（ArrayList）","slug":"Java-ArrayList","date":"2015-04-13T10:46:56.000Z","updated":"2018-03-19T11:06:09.360Z","comments":true,"path":"2015/04/13/Java-ArrayList/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/13/Java-ArrayList/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://mp.blog.csdn.net/postedit/79533661），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是JAVA中的集合框架。 /** * 学生类 * @author Administrator * */ public class Student { private String id; private String name; private Set course; private Student(String id,String name){ this.id = id; this.name = name; this.course = new HashSet(); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Set getCourse() { return course; } public void setCourse(Set course) { this.course = course; } } /** * 课程类 * @author Administrator * */ public class Course { private String id; private String name; Course(String id,String name){ this.id=id; this.name=name; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 单个元素的插入 import java.util.ArrayList; import java.util.List; /** * 备选课程类 * @author Administrator * */ public class ListTest { /** * 用于存放备选课程的List */ public List coursesToSelect; public ListTest(){ this.coursesToSelect = new ArrayList(); } /** * 用于往coursesToSelect中添加备选课程 */ public void testAdd(){ Course cr1 = new Course(&quot;1&quot;,&quot;数据结构&quot;);//new一个Course类的数据类型 coursesToSelect.add(cr1);//所为一条数据插入List中 Course temp = (Course)coursesToSelect.get(0);//获取LIst中的第一条数据，课程存入集合都变成Object类型，取出时需要类型转换 System.out.println(&quot;添加了课程：&quot; + temp.getId() + temp.getName()); } public static void main(String [] args) { ListTest lt = new ListTest(); lt.testAdd(); } } 多个元素的同时插入数组的集合插入，由单个元素的add方法，变成addAll方法 import java.util.ArrayList; import java.util.Arrays; import java.util.List; /** * 备选课程类 * @author Administrator * */ public class ListTest { /** * 用于存放备选课程的List */ public List coursesToSelect; public ListTest(){ this.coursesToSelect = new ArrayList(); } /** * 用于往coursesToSelect中添加备选课程 */ public void testAdd(){ Course cr1 = new Course(&quot;1&quot;,&quot;数据结构&quot;);//new一个Course类的数据类型 coursesToSelect.add(cr1);//所为一条数据插入List中 Course temp = (Course)coursesToSelect.get(0);//获取LIst中的第一条数据 System.out.println(&quot;添加了课程：&quot; + temp.getId() + &quot;:&quot; + temp.getName()); Course cr2 = new Course(&quot;2&quot;,&quot;C语言&quot;); coursesToSelect.add(0, cr2); //两个参数的add方法，选择插入元素的位置 Course temp2 = (Course) coursesToSelect.get(0);//将元素插入到第一条 System.out.println(&quot;添加了课程：&quot; + temp2.getId() + &quot;:&quot; + temp2.getName());//观察打印的第一条的值 // 以下方法会抛出数组下标越界异常 // Course cr3 = new Course(&quot;3&quot;,&quot;test&quot;); // coursesToSelect.add(4, cr3); //插入位置大于容量，数组下标越界 /** * 多个元素的同时插入 */ Course[] course = {new Course(&quot;3&quot;,&quot;离散数学&quot;), new Course(&quot;4&quot;,&quot;汇编语言&quot;)}; coursesToSelect.addAll(Arrays.asList(course)); //添加数组用addAll Course temp3 = (Course) coursesToSelect.get(2); Course temp4 = (Course) coursesToSelect.get(3); System.out.println(&quot;添加了两门课程：&quot; + temp3.getId() + &quot;:&quot; + temp3.getName() + &quot;;&quot; + temp4.getId() + &quot;:&quot; + temp4.getName()); //按位置插入 Course[] course2 = {new Course(&quot;5&quot;,&quot;高等数学&quot;),new Course(&quot;6&quot;,&quot;大学英语&quot;)}; coursesToSelect.addAll(2, Arrays.asList(course2)); Course temp5 = (Course)coursesToSelect.get(2); Course temp6 = (Course)coursesToSelect.get(3); System.out.println(&quot;添加了两门课程：&quot; + temp5.getId() + &quot;:&quot; + temp5.getName() + &quot;;&quot; + temp6.getId() + &quot;:&quot; + temp6.getName()); } public static void main(String [] args) { ListTest lt = new ListTest(); lt.testAdd(); } } 查询元素的三种写法 /** * 取得List中的元素的方法 * @param args */ public void testGet(){ int size = coursesToSelect.size();//创建一个Size变量用来接收Lisr的长度 System.out.println(&quot;有如下课程可选：&quot;); for(int i=0;i&lt;coursesToSelect.size();i++){ Course cr = (Course) coursesToSelect.get(i); System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } /** * 通过迭代器来遍历List * @param args */ public void testIterator(){ //通过集合的方法，取得迭代器的实例。 Iterator it = coursesToSelect.iterator(); System.out.println(&quot;有如下课程可选（通过迭代器访问）：&quot;); while (it.hasNext()) {//it.hasNext如果含有元素就返回真值 Course cr = (Course)it.next(); System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } /** * 通过for each方法访问集合元素 * 迭代器的简便写法 * @param args */ public void testForEach(){ System.out.println(&quot;有如下课程可选（通过for each访问）：&quot;); for(Object obj:coursesToSelect){//去遍历coursesToSelect集合中的每一个元素，把它取出来作为Object的一个变量 //（当一个元素存入到集合中的时候，他的类型是被忽略了的，集合只是拿他当Object用），当取出来的时候也是一个Object，因此 Course cr =(Course)obj;//当他取出来后，需要做强转 System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } main函数中调用 ListTest lt = new ListTest(); lt.testGet(); lt.testIterator(); lt.testForEach(); 修改元素 /** * 修改List中的元素 * @param args */ public void testModify(){ coursesToSelect.set(4, new Course(&quot;7&quot;,&quot;毛概&quot;));//设置4位置的元素为：7,毛概 } 删除元素 /** * 删除List中的元素 * @param args */ public void testRemove(){ // Course cr = (Course) coursesToSelect.get(4); // System.out.println(&quot;我是课程：&quot; + cr.getId() + &quot;:&quot; +cr.getName() + &quot;我即将被删除&quot;); // coursesToSelect.remove(cr); System.out.println(&quot;即将删除4位置上的课程！&quot;); coursesToSelect.remove(4); System.out.println(&quot;成功删除课程！&quot;); testForEach();//调用前面写的遍历方法遍历数据 /** * 同时删除多行时 */ // System.out.println(&quot;即将删除4位置和5位置上的课程！&quot;); // Course[] courses = {(Course) coursesToSelect.get(4),(Course) coursesToSelect.get(5)};//新建一个课程的数组将4位置和5位置的元素 // //加入到数组中 // coursesToSelect.removeAll(Arrays.asList(courses));///调用removeAll方法，通过asList工具类，把courses数组转化为集合作为参数传递进去 // testForEach();//调用前面写的遍历方法遍历数据 } main函数中调用 ListTest lt = new ListTest(); lt.testRemove(); 小节ListTest类完整代码 import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; import java.util.List; /** * 备选课程类 * @author Administrator * */ public class ListTest { /** * 用于存放备选课程的List */ public List coursesToSelect; public ListTest(){ this.coursesToSelect = new ArrayList(); } /** * 用于往coursesToSelect中添加备选课程 */ public void testAdd(){ Course cr1 = new Course(&quot;1&quot;,&quot;数据结构&quot;);//new一个Course类的数据类型 coursesToSelect.add(cr1);//所为一条数据插入List中 Course temp = (Course)coursesToSelect.get(0);//获取LIst中的第一条数据 System.out.println(&quot;添加了课程：&quot; + temp.getId() + &quot;:&quot; + temp.getName()); Course cr2 = new Course(&quot;2&quot;,&quot;C语言&quot;); coursesToSelect.add(0, cr2); //两个参数的add方法，选择插入元素的位置 Course temp2 = (Course) coursesToSelect.get(0);//将元素插入到第一条,对象存入集合都变成Object类型，取出时需要类型转换 System.out.println(&quot;添加了课程：&quot; + temp2.getId() + &quot;:&quot; + temp2.getName());//观察打印的第一条的值 coursesToSelect.add(cr1);//所为一条数据插入List中 Course temp0 = (Course)coursesToSelect.get(2);//获取LIst中的第一条数据 System.out.println(&quot;添加了课程：&quot; + temp0.getId() + &quot;:&quot; + temp0.getName()); // 以下方法会抛出数组下标越界异常 // Course cr3 = new Course(&quot;3&quot;,&quot;test&quot;); // coursesToSelect.add(4, cr3); //插入位置大于容量，数组下标越界 Course[] course = {new Course(&quot;3&quot;,&quot;离散数学&quot;), new Course(&quot;4&quot;,&quot;汇编语言&quot;)}; coursesToSelect.addAll(Arrays.asList(course)); //添加数组用addAll Course temp3 = (Course) coursesToSelect.get(3); Course temp4 = (Course) coursesToSelect.get(4); System.out.println(&quot;添加了两门课程：&quot; + temp3.getId() + &quot;:&quot; + temp3.getName() + &quot;;&quot; + temp4.getId() + &quot;:&quot; + temp4.getName()); //按位置插入 Course[] course2 = {new Course(&quot;5&quot;,&quot;高等数学&quot;),new Course(&quot;6&quot;,&quot;大学英语&quot;)}; coursesToSelect.addAll(2, Arrays.asList(course2)); Course temp5 = (Course)coursesToSelect.get(2); Course temp6 = (Course)coursesToSelect.get(3); System.out.println(&quot;添加了两门课程：&quot; + temp5.getId() + &quot;:&quot; + temp5.getName() + &quot;;&quot; + temp6.getId() + &quot;:&quot; + temp6.getName()); } /** * 取得List中的元素的方法 * @param args */ public void testGet(){ int size = coursesToSelect.size();//创建一个Size变量用来接收Lisr的长度 System.out.println(&quot;有如下课程可选：&quot;); for(int i=0;i&lt;coursesToSelect.size();i++){ Course cr = (Course) coursesToSelect.get(i); System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } /** * 通过迭代器来遍历List * @param args */ public void testIterator(){ //通过集合的方法，取得迭代器的实例。 Iterator it = coursesToSelect.iterator(); System.out.println(&quot;有如下课程可选（通过迭代器访问）：&quot;); while (it.hasNext()) {//it.hasNext如果含有元素就返回真值 Course cr = (Course)it.next(); System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } /** * 通过for each方法访问集合元素 * 迭代器的简便写法 * @param args */ public void testForEach(){ System.out.println(&quot;有如下课程可选（通过for each访问）：&quot;); for(Object obj:coursesToSelect){//去遍历coursesToSelect集合中的每一个元素，把它取出来作为Object的一个变量 //（当一个元素存入到集合中的时候，他的类型是被忽略了的，集合只是拿他当Object用），当取出来的时候也是一个Object，因此 Course cr =(Course)obj;//当他取出来后，需要做强转 System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } /** * 修改List中的元素 * @param args */ public void testModify(){ coursesToSelect.set(4, new Course(&quot;7&quot;,&quot;毛概&quot;));//设置4位置的元素为：7,毛概 } /** * 删除List中的元素 * @param args */ public void testRemove(){ // Course cr = (Course) coursesToSelect.get(4); // System.out.println(&quot;我是课程：&quot; + cr.getId() + &quot;:&quot; +cr.getName() + &quot;我即将被删除&quot;); // coursesToSelect.remove(cr); System.out.println(&quot;即将删除4位置上的课程！&quot;); coursesToSelect.remove(4); System.out.println(&quot;成功删除课程！&quot;); testForEach();//调用前面写的遍历方法遍历数据 /** * 同时删除多行时 */ // System.out.println(&quot;即将删除4位置和5位置上的课程！&quot;); // Course[] courses = {(Course) coursesToSelect.get(4),(Course) coursesToSelect.get(5)};//新建一个课程的数组将4位置和5位置的元素 // //加入到数组中 // coursesToSelect.removeAll(Arrays.asList(courses));///调用removeAll方法，通过asList工具类，把courses数组转化为集合作为参数传递进去 // testForEach();//调用前面写的遍历方法遍历数据 } public static void main(String [] args) { ListTest lt = new ListTest(); lt.testAdd(); lt.testGet(); lt.testIterator(); lt.testForEach(); lt.testModify(); lt.testForEach(); lt.testRemove(); } } 那么，能否向集合中添加一些奇怪的元素呢？ /** * 往集合中添加一些奇怪的东西 * @param args */ public void testType(){ System.out.println(&quot;能否往List中添加一些奇怪的东西呢？&quot;); coursesToSelect.add(&quot;我不是课程，我只是一个无辜的字符串！！&quot;); } 调用 public static void main(String [] args) { ListTest lt = new ListTest(); lt.testAdd(); lt.testType(); lt.testForEach(); } 很明显，抛出了异常。 那么，有没有一种方法可以控制数据的类型呢？ 答案肯定是有的，那就是JAVA中的，泛型 下章泛型学习：http://blog.csdn.net/weimeig/article/details/79535182 伪代码助记 class TestList{ private List&lt;Course&gt; course; //构造函数初始化 public TestList(){ this.course = new ArrayList&lt;Course&gt;(); } //增加 public void add(){ course.add(new Course(&quot;1&quot;,&quot;课程&quot;)); } //删除 public void remove(){ course.remove(1); } //修改 public void set(){ course.set(&quot;1&quot;,new Course(&quot;1&quot;,&quot;课程&quot;)); } //查询 public void ForEach(){ // for(Object obj:course){ // Course cr = (Course)obj; // } for(Course cr:course){} } public static void main(String[] args){} }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"抽象类","slug":"AbstractClass","date":"2015-03-20T10:12:55.000Z","updated":"2018-03-21T04:11:07.315Z","comments":true,"path":"2015/03/20/AbstractClass/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/03/20/AbstractClass/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79498536），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是抽象类。 /** *abstract是一个修饰符 *可以修饰方法，类 *1.当我们多个类存在相同的功能时，但是功能的主体不同，这时我们进行向上抽取 *只抽取功能的定义不抽取功能的主体 * * 抽象类的特点： * 1.抽象方法一定要在抽象类中 * 2.抽象类和抽象方法必须要被abstract关键字修饰 * 3.抽象的类是不能被创建对象，因为调用抽象的方法没意义 * 4.抽象类中的方法要被使用，必须由之类重写抽象类中的方法，然后创建之类对象来调用。 * 5.抽象类中可以定义非抽象的方法，有时我们需要此类不能被new关键字创建对象时， * 可以用abstract将此类变成抽象类 * 6.子类如果只重写一部分的抽象方法，那么该子类还是一个抽象类。如果抽象类的方法 * 要被使用，子类必须重写抽象类中的所有方法。 * * 值得注意：抽象类和普通的类没有太大的不同。 * 1.抽象类无法通过new关键字创建对象 * 2.抽象类里面可以有抽象的方法 */ abstract class Animal{ abstract void sing(); void show(){ System.out.println(&quot;你好&quot;); } } class Cat extends Animal{ void sing(){ System.out.println(&quot;喵喵唱歌&quot;); } } class Dog extends Animal{ void sing(){ System.out.println(&quot;汪汪唱歌&quot;); } } public class chouxianglei { public static void main(String[] args) { Animal a=new Dog();//Animal是抽象类不能new对象，但可以接收子类对象 a.sing(); } } 我们不难发现，不同的子类继承父类后，各自有不同的重写需求，那么父类中的方法突然变得没有了意义，这时候，我们可以将父类Animal中的 void show(){ System.out.println(&quot;你好&quot;); } 方法改为看不懂的抽象方法，abstract void sing();此时会报错，因为，抽象方法需要存在抽象类中， 所以，将类定义为abstract class Animal抽象类。当然，方法体中的abstract void sing()不加abstract， 编译的时候是会默认加上去的。","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"toString方法","slug":"Java-toString","date":"2015-03-19T09:40:25.000Z","updated":"2018-03-19T09:45:25.127Z","comments":true,"path":"2015/03/19/Java-toString/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/03/19/Java-toString/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79497172），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是toString方法。 public class toStringFangFa { public static void main(String []args){ System.out.println(new String(&quot;你好&quot;)); } } 我们不难发现，在这行代码中，我们找不到字符串的时候，直接new的一个String传你好进去，他可以正常打印运行，因为在java中，我们尽管没有调用toString方法，当他给我们默认的调用了，出现的效果和我们的 public class toStringFangFa { public static void main(String []args){ System.out.println(new String(&quot;你好&quot;).toString()); } } 是一样的。 好了，大家可以继续练习一下。 class Ca{ String name; int avg; public String toString(){ return &quot;我的名字&quot; + name + &quot;,我的年龄&quot; + avg; } } public class toStringFangFa { public static void main(String []args){ Ca ca = new Ca(); ca.name = &quot;张三&quot;; ca.avg = 18; System.out.println(ca); } }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"OkHttp框架读书总结笔记","slug":"OkHttpReadingNotes","date":"2015-02-11T03:55:21.000Z","updated":"2018-03-18T04:32:48.958Z","comments":true,"path":"2015/02/11/OkHttpReadingNotes/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/02/11/OkHttpReadingNotes/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78656734），请尊重他人的辛勤劳动成果，谢谢 一、添加依赖 build.gradle dependencies { compile &apos;com.squareup.okhttp3:okhttp:3.2.0&apos; compile &apos;com.squareup.okio:okio:1.7.0&apos; } 权限: &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; HelloOkhttp import java.io.IOException; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * Created by Administrator on 2017/11/27. */ public class HelloOkhttp { public static void main(String [] args) throws IOException { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder(). url(&quot;http://www.baidu.com&quot;).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()) { System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } } } QueryHttp import java.io.IOException; import okhttp3.HttpUrl; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * Created by Administrator on 2017/11/27. */ public class QueryHttp { public static void main(String args[]) { OkHttpClient client = new OkHttpClient(); HttpUrl httpUrl = HttpUrl.parse(&quot;https://api.heweather.com/x3/weather&quot;). newBuilder(). addQueryParameter(&quot;city&quot;, &quot;beijing&quot;). addQueryParameter(&quot;key&quot;, &quot;d17ce22ec5404ed883e1cfcaca0ecaa7&quot;). build(); String url = httpUrl.toString(); System.out.println(httpUrl.toString()); Request request = new Request.Builder().url(url).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()) { System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } } } HeadHttp import java.io.IOException; import okhttp3.Headers; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * Created by Administrator on 2017/11/27. */ /** * 请求头 */ public class HeadHttp { public static void HadeHttp(String url){ OkHttpClient client =new OkHttpClient(); Request request = new Request.Builder().url(url). addHeader(&quot;User-Agent&quot;,&quot;from nate http&quot;).build(); try { Response response = client.newCall(request).execute(); if(response.isSuccessful()){ Headers headers = response.headers(); for(int i=0;i&lt;headers.size();i++){ System.out.println(headers.name(i)+&quot;:&quot;+headers.value(i)); } } } catch (IOException e) { e.printStackTrace(); } } public static void main(String []args){ HadeHttp(&quot;http://www.baidu.com&quot;); } } 同步和异步请求比较 import java.io.IOException; import okhttp3.Call; import okhttp3.Callback; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * Created by Administrator on 2017/11/27. */ /**同步 * */ public class AsyncHttp { public static void SendHttp(String url){ OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(url).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()){ System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } } /** *异步 * */ public static void SendAsyncHttp(String url){ System.out.println(Thread.currentThread().getId()); OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(url).build(); client.newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, Response response) throws IOException { if (response.isSuccessful()){ System.out.println(Thread.currentThread().getId()); } } }); } public static void main(String [] args){ SendAsyncHttp(&quot;http://www.baidu.com&quot;); // SendHttp(&quot;http://www.baidu.com&quot;); } }","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"微信支付及支付宝支付集成","slug":"WeChatAlipayPayIntegr","date":"2014-12-11T04:19:15.000Z","updated":"2018-03-18T04:25:57.390Z","comments":true,"path":"2014/12/11/WeChatAlipayPayIntegr/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/12/11/WeChatAlipayPayIntegr/","excerpt":"","text":"文章转载自互联网 1.微信支付 1.微信官方的集成文档 2.微信官方资源下载 首先官方文档实在是没有看懂，里面有很多东西都没有提及到，反正当时我看的时候就没有看懂可能是能力有限吧！ 先说一下我们这边的需求吧，我们这边订单处理是在服务器，没有在app内进行，一些字段都是从服务器返回的，这里只要请求之后，唤起微信支付就算是完成了，还是很简单的一个操作，下面我们就一步一步往下说吧！集成步骤如下：1.首先就是导入最新的SDK，这个从微信官方资源下载处就可以下载（这里就不说了）2.添加必要的权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 3.创建一个wxapi的包并且创建一个WXEntryActivity类这里有几点要注意以下： 1.首先这个包必须在你项目的根目录下创建的，例如应用程序的包名为net.sourceforge.simcpux，则新添加的应该在net.sourceforge.simcpux.wxapi下面） 2.在AndroidManifest中添加相应的标签 &lt;activity android:name=&quot;.wxapi.WXEntryActivity&quot; android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot; android:exported=&quot;true&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot;/&gt; 4.关于APPID存放问题 关于这个APPID的存放，因为做了分享，所以我就直接存放到本地了的静态字段中了，还有就是从服务器请求，其实从服务器请求我有一点我不太明白之后再说！5.创建一个WXPayEntryActivity类 创建的这个类我就直接放在wxapi中了，不知都放在别的地方会不会有什么问题，没有尝试过。这个类就是用来支付回调的类了。关于这个类有几点说明： 1.这个类是集成Activity的实现IWXAPIEventHandler接口的，别忘了在AndroidManifest注册，否则不走回调的！ &lt;activity android:name=&quot;.wxapi.WXPayEntryActivity&quot; android:exported=&quot;true&quot; android:launchMode=&quot;singleTop&quot;/&gt; 2.在onCreat()方法中要注册到微信，这里要注意这个是你微信成功签名的那个APPID private IWXAPI api; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //这里面的APPID就是存放在本地的微信的ID api = WXAPIFactory.createWXAPI(this, Constants.ACCOUNT.APP_ID); api.handleIntent(getIntent(), this); } 3.在onResp(BaseResp resp)方法中处理回调数据，也就是处理回调失败啊，成功啊什么的！ @Override public void onResp(BaseResp resp) { Logger.e(&quot;WXPayEntryActivity回调微信支付的结果errCode = &quot; + resp.errCode); if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) { int errCode = resp.errCode; if (errCode == -1) {/*支付失败*/ Toast.makeText(this, &quot;支付失败&quot;, Toast.LENGTH_LONG).show(); } else if (errCode == 0) {/*支付成功*/ Toast.makeText(this, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show(); EventBusUtils.post(new EventBusWechatGoldBean()); } else if (errCode == -2) {/*取消支付*/ Toast.makeText(this, &quot;取消支付&quot;, Toast.LENGTH_LONG).show(); } finish(); } } 6.之后就可以在相应的地方从服务器获取相应的参数调用微信支付了 调用的代码如下： /** * 唤起微信充值界面 */ private void payWechat(WechatGoldBean wechatGoldBean) { PayReq req = new PayReq(); req.appId = wechatGoldBean.getAppid(); req.partnerId = wechatGoldBean.getPartnerid(); req.prepayId = wechatGoldBean.getPrepayid(); req.nonceStr = wechatGoldBean.getNoncestr(); req.timeStamp = wechatGoldBean.getTimestamp(); req.packageValue = &quot;Sign=WXPay&quot;; req.sign = wechatGoldBean.getSign(); IWXAPI api = WXAPIFactory.createWXAPI(mContext, wechatGoldBean.getAppid()); api.sendReq(req); } 这里WechatGoldBean是从服务器请求来的实体类，这里面封装了关于微信支付的所有订单信息，这样做的好处就是生成订单服务器做比较安全，第二也省去了自己的麻烦。到了这里基本上都能唤起微信支付了常见问题： 关于微信的签名要说明的问题：首先按照微信的签名的话，一般步骤都可以往下走，但是有一点需要注意就是签完名之后，如果你打包成正式版的话也就是releasea签名的话要用正式的包安装才能唤起微信，否则会出错的，如果要是想使用Dug签名的话，你要把签名后的keystore替换掉android studio的默认签名就可以使用了。关于微信支付能只能想到这么多了，基本上集成就这么多问题，有什么不懂得欢迎在下方留言，看到了我会第一时间回复！！！2.支付宝支付 1.支付宝官方集成文档2.支付宝官方资源下载 其实支付宝支付的话还是比较简单的按照Demo集成的话基本上没有什么问题就是导入几个类就可以了。 还是先说一下我们这边的需求，还是订单处理在服务器这边，没有在app内进行，一些字段都是从服务器返回的，这里只要请求之后，唤起支付宝支付就算完成了，比较简单，下面一步一步往下说吧！集成步骤如下：1.首先就是导入最新的SDK，这个从支付宝官方资源下载处就可以下载（这里就不说了）2.添加必要的权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; 3.在AndroidManifest中添加相应的标签 &lt;activity android:name=&quot;com.alipay.sdk.app.H5PayActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|navigation&quot; android:exported=&quot;false&quot; android:screenOrientation=&quot;behind&quot; &gt; &lt;/activity&gt; &lt;activity android:name=&quot;com.alipay.sdk.auth.AuthActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|navigation&quot; android:exported=&quot;false&quot; android:screenOrientation=&quot;behind&quot; &gt; &lt;/activity&gt; 4.支付接口调用 这里说明一下，支付宝调用的时候必须在异步线程中调用！切记 public void payAlipay(final ALipayGoldBean aLipayGoldBean) { Runnable payRunnable = new Runnable() { @Override public void run() { PayTask alipay = new PayTask((DiamondActivity) mContext); Map&lt;String, String&gt; result = alipay.payV2(aLipayGoldBean.getPayInfo(), true); Message msg = new Message(); msg.what = SDK_PAY_FLAG; msg.obj = result; mHandler.sendMessage(msg); } }; Thread payThread = new Thread(payRunnable); payThread.start(); } 这里说明一下：这个ALipayGoldBean是从服务器请求过来的，里面就一个payInfo参数，其实就是payV2()所需要的定单的信息(orderInfo)！5.支付结果的处理 官方文档上说有两种处理方式，但是作为APP我只按第一种处理方式进行的，第二种没有研究！ private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case SDK_PAY_FLAG: @SuppressWarnings(&quot;unchecked&quot;) PayResult payResult = new PayResult((Map&lt;String, String&gt;) msg.obj); String resultStatus = payResult.getResultStatus(); // 判断resultStatus 为9000则代表支付成功 if (TextUtils.equals(resultStatus, &quot;9000&quot;)) {/*支付成功*/ Toast.makeText(mContext, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show(); } else {/*支付失败*/ Toast.makeText(mContext, &quot;支付失败&quot;, Toast.LENGTH_SHORT).show(); } break; } } }; 这里有几点说明的问题：1.这个PayResult从Demo中直接复制过来就行，要不没有的；如果你不想复制，好的在下面： public class PayResult { private String resultStatus; private String result; private String memo; public PayResult(Map&lt;String, String&gt; rawResult) { if (rawResult == null) { return; } for (String key : rawResult.keySet()) { if (TextUtils.equals(key, &quot;resultStatus&quot;)) { resultStatus = rawResult.get(key); } else if (TextUtils.equals(key, &quot;result&quot;)) { result = rawResult.get(key); } else if (TextUtils.equals(key, &quot;memo&quot;)) { memo = rawResult.get(key); } } } @Override public String toString() { return &quot;resultStatus={&quot; + resultStatus + &quot;};memo={&quot; + memo + &quot;};result={&quot; + result + &quot;}&quot;; } /** * @return the resultStatus */ public String getResultStatus() { return resultStatus; } /** * @return the memo */ public String getMemo() { return memo; } /** * @return the result */ public String getResult() { return result; } } 2.关于Handler内存泄漏的问题，自己可以改的，如果改不了百度一下就可以了。至此支付宝支付就算集成完毕了，是不是很简单！作为小白的我们真的要多学习，多看别人的代码，学习这个东西就是这样，不论什么天才和小白，没有什么捷径可以走，只有不断的学习才能跟得上时代，不被淘汰！座右铭：只有自己强大才能无所畏惧！","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Java接口回调，Android接口回调读书笔记","slug":"InterfaceCallback","date":"2014-05-13T04:04:35.000Z","updated":"2018-03-18T04:49:39.863Z","comments":true,"path":"2014/05/13/InterfaceCallback/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/05/13/InterfaceCallback/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 单看文章比较难理解，照着多敲几遍代码就理解了 回调就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，这样子说你是不是有点晕晕的，其实我刚开始也是这样不理解，看了人家说比较经典的回调方式： Class A实现接口CallBack callback——背景1 class A中包含一个class B的引用b ——背景2 class B有一个参数为callback的方法f(CallBack callback) ——背景3 A的对象a调用B的方法 f(CallBack callback) ——A类调用B类的某个方法 C 然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D 大家都喜欢用打电话的例子，好吧，为了跟上时代，我也用这个例子好了，我这个例子采用异步加回调 有一天小王遇到一个很难的问题，问题是“1 + 1 = ?”，就打电话问小李，小李一下子也不知道，就跟小王说，等我办完手上的事情，就去想想答案，小王也不会傻傻的拿着电话去等小李的答案吧，于是小王就对小李说，我还要去逛街，你知道了答案就打我电话告诉我，于是挂了电话，自己办自己的事情，过了一个小时，小李打了小王的电话，告诉他答案是2 /** * 这是一个回调接口 * @author xiaanming * */ public interface CallBack { /** * 这个是小李知道答案时要调用的函数告诉小王，也就是回调函数 * @param result 是答案 */ public void solve(String result); } /** * 这个是小王 * @author xiaanming * 实现了一个回调接口CallBack，相当于-----&gt;背景一 */ public class Wang implements CallBack { /** * 小李对象的引用 * 相当于-----&gt;背景二 */ private Li li; /** * 小王的构造方法，持有小李的引用 * @param li */ public Wang(Li li){ this.li = li; } /** * 小王通过这个方法去问小李的问题 * @param question 就是小王要问的问题,1 + 1 = ? */ public void askQuestion(final String question){ //这里用一个线程就是异步， new Thread(new Runnable() { @Override public void run() { /** * 小王调用小李中的方法，在这里注册回调接口 * 这就相当于A类调用B的方法C */ li.executeMessage(Wang.this, question); } }).start(); //小网问完问题挂掉电话就去干其他的事情了，诳街去了 play(); } public void play(){ System.out.println(&quot;我要逛街去了&quot;); } /** * 小李知道答案后调用此方法告诉小王，就是所谓的小王的回调方法 */ @Override public void solve(String result) { System.out.println(&quot;小李告诉小王的答案是---&gt;&quot; + result); } } /** * 这个就是小李啦 * @author xiaanming * */ public class Li { /** * 相当于B类有参数为CallBack callBack的f()----&gt;背景三 * @param callBack * @param question 小王问的问题 */ public void executeMessage(CallBack callBack, String question){ System.out.println(&quot;小王问的问题---&gt;&quot; + question); //模拟小李办自己的事情需要很长时间 for(int i=0; i&lt;10000;i++){ } /** * 小李办完自己的事情之后想到了答案是2 */ String result = &quot;答案是2&quot;; /** * 于是就打电话告诉小王，调用小王中的方法 * 这就相当于B类反过来调用A的方法D */ callBack.solve(result); } } /** * 测试类 * @author xiaanming * */ public class Test { public static void main(String[]args){ /** * new 一个小李 */ Li li = new Li(); /** * new 一个小王 */ Wang wang = new Wang(li); /** * 小王问小李问题 */ wang.askQuestion(&quot;1 + 1 = ?&quot;); } } 通过上面的那个例子你是不是差不多明白了回调机制呢，上面是一个异步回调，我们看看同步回调吧，onClick（）方法 现在来分析分析下Android View的点击方法onclick（）;我们知道onclick()是一个回调方法，当用户点击View就执行这个方法，我们用Button来举例好了 //这个是View的一个回调接口 /** * Interface definition for a callback to be invoked when a view is clicked. */ public interface OnClickListener { /** * Called when a view has been clicked. * * @param v The view that was clicked. */ void onClick(View v); } package com.example.demoactivity; import android.app.Activity; import android.os.Bundle; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.Toast; /** * 这个就相当于Class A * @author xiaanming * 实现了 OnClickListener接口----&gt;背景一 */ public class MainActivity extends Activity implements OnClickListener{ /** * Class A 包含Class B的引用-----&gt;背景二 */ private Button button; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button1); /** * Class A 调用View的方法,而Button extends View-----&gt;A类调用B类的某个方法 C */ button.setOnClickListener(this); } /** * 用户点击Button时调用的回调函数，你可以做你要做的事 * 这里我做的是用Toast提示OnClick */ @Override public void onClick(View v) { Toast.makeText(getApplication(), &quot;OnClick&quot;, Toast.LENGTH_LONG).show(); } } 下面是View类的setOnClickListener方法，就相当于B类咯，只把关键代码贴出来 /** * 这个View就相当于B类 * @author xiaanming * */ public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource { /** * Listener used to dispatch click events. * This field should be made private, so it is hidden from the SDK. * {@hide} */ protected OnClickListener mOnClickListener; /** * setOnClickListener()的参数是OnClickListener接口------&gt;背景三 * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */ public void setOnClickListener(OnClickListener l) { if (!isClickable()) { setClickable(true); } mOnClickListener = l; } /** * Call this view&apos;s OnClickListener, if it is defined. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */ public boolean performClick() { sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); if (mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); //这个不就是相当于B类调用A类的某个方法D，这个D就是所谓的回调方法咯 mOnClickListener.onClick(this); return true; } return false; } } 这个例子就是Android典型的回调机制，看完这个你是不是更进一步的理解了回调机制呢？ 线程run()也是一个回调方法，当执行Thread的start（）方法就会回调这个run()方法，还有处理消息都比较经典等等 案例二、 接口回调简单理解就是：类A中调用B类的中方法C，而B又反过去调用A中的方法D，然后D称为A的回调方法。是不是心中有一万只草泥马在奔腾，到底说的是什么。感觉像是你中有我，我中有你，纠缠不清。举个通俗易懂的例子，比如顾客是A，厨师是B。面粉是接口Callback。然后面粉的吃法D是在顾客A的手中，厨师B有包子的做法C。现在需求是A有面粉，想吃包子，但是A是不会做包子，就需要去找厨师，让他调方法C做包子，A就把面粉Callback给了厨师，至于厨师怎么做，A不管，A只要你做好了给我一个结果（包子）就OK了。至于包子怎么吃，我是直接吃，还是蘸点醋吃，那是A的事了（A怎么吃的过程就是方法D里具体执行的代码）。下面结合一个简单的例子看就容易多了。首先是定义接口（面粉）： package com.example.interfacecallbackdemo; public interface Callback { //因为是一堆面粉，肯定是没法吃的，所以没有具体的方法体，俗称“吃法” public void D(String result); } 然后定义A类（客户）： package com.example.interfacecallbackdemo; public class A implements Callback{ /** * B类引用 */ private B b; public A(B b) { this.b = b; } /** * A类通过该方法调用B的方法C（可理解为找到厨师并将面粉给他）。 */ public void selectMenu(){ b.C(this); } /** * A类中的D方法，也称为A类的回调方法（厨师做好包子将包子（result）返回给顾客A） */ @Override public void D(String result) { System.out.print(result); } } 然后是B类： package com.example.interfacecallbackdemo; public class B { /** * B类的C方法（接受面粉Callback,然后开工做包子，做好后返回给客户A）。 */ public void C(Callback callback){ String result = &quot;2&quot;; callback.D(result); } } 再加上一个执行的对象，我是利用android中button调用的： package com.example.interfacecallbackdemo; import android.app.Activity; import android.os.Bundle; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; public class MainActivity extends Activity implements OnClickListener{ private A a; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btn_main) .setOnClickListener(this); a = new A(new B()); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.btn_main: a.selectMenu(); break; default: break; } } } （ABCD分别对应什么自己脑补，很easy吧）前面说的是A 调用B中的方法C，B又反过来调用A中的方法D。在代码中我就直接用ABCD ,简单、直接、粗暴。但是，B类的C方法的参数不必一定要把Callback作为参数，如果C方法中没有这个参数，那在B类中一定要在其它地方把Callback接收进来。比如，我把B类稍微改动一下： package com.example.interfacecallbackdemo; public class B { private Callback callback; public B(Callback callback){ this.callback = callback; } /** * B类的C方法 */ public void C(){ String result = &quot;2&quot;; callback.D(result); } } 此时A类也要做相应的调整： package com.example.interfacecallbackdemo; import android.util.Log; public class A { /** * B类引用 */ private B b; /** * A类同过该方法调用B类的C方法 */ public void selectMenu(){ b = new B(new Callback() { @Override public void D(String result) { System.out.print(result); } }); b.C(); } } 呃，这个算是标准版的变异版，其实也是很简单的，毕竟这种可能是大家项目中实际中会见到而不至于弄不清楚，但是有一点，C方法中一定会有接口的实例对象调用其抽象方法。其实我们不需要按接口回调的定义去对比，重要的是理解其原理机制，只需记住，哪个类传递Callback实例对象过去的，就是我们所说的A，接受的就是B。接口回调在android中是非常常见的，典型的就是各种监听器了，如果去分析下源码，你就会发现跟上面得那个例子大同小异。","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"Retrofit框架读书总结笔记（一）","slug":"RetrofitReadNotesOne","date":"2014-05-11T03:55:21.000Z","updated":"2018-03-18T04:29:21.995Z","comments":true,"path":"2014/05/11/RetrofitReadNotesOne/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/05/11/RetrofitReadNotesOne/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78656178），请尊重他人的辛勤劳动成果，谢谢 一、添加依赖 build.gradle dependencies { compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos; // Retrofit库 compile &apos;com.squareup.okhttp3:okhttp:3.1.2&apos; // Okhttp库 } 点击右上角Sync Now 二、 （1）RestService类 import java.util.WeakHashMap; import okhttp3.MultipartBody; import okhttp3.RequestBody; import okhttp3.ResponseBody; import retrofit2.Call; import retrofit2.http.Body; import retrofit2.http.DELETE; import retrofit2.http.FieldMap; import retrofit2.http.FormUrlEncoded; import retrofit2.http.GET; import retrofit2.http.Multipart; import retrofit2.http.POST; import retrofit2.http.PUT; import retrofit2.http.Part; import retrofit2.http.QueryMap; import retrofit2.http.Streaming; import retrofit2.http.Url; /** * Created by Administrator on 2017/11/28. */ public interface RestService { @GET Call&lt;String&gt; get(@Url String url, @QueryMap WeakHashMap&lt;String, Object&gt; params); @FormUrlEncoded @POST Call&lt;String&gt; post(@Url String url, @FieldMap WeakHashMap&lt;String, Object&gt; params); @POST Call&lt;String&gt; postRaw(@Url String url, @Body RequestBody body); @FormUrlEncoded @PUT Call&lt;String&gt; put(@Url String url, @FieldMap WeakHashMap&lt;String, Object&gt; params); @PUT Call&lt;String&gt; putRaw(@Url String url, @Body RequestBody body); @DELETE Call&lt;String&gt; delete(@Url String url, @QueryMap WeakHashMap&lt;String, Object&gt; params); @Streaming @GET Call&lt;ResponseBody&gt; download(@Url String url, @QueryMap WeakHashMap&lt;String, Object&gt; params); @Multipart @POST Call&lt;String&gt; upload(@Url String url, @Part MultipartBody.Part file); }","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"AndroidStudio导入网上下载的代码慢及AndroidStudio不提示代码的解决方法","slug":"ASImportCodeNotPrompt","date":"2014-03-18T04:01:25.000Z","updated":"2018-03-18T04:03:35.817Z","comments":true,"path":"2014/03/18/ASImportCodeNotPrompt/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/03/18/ASImportCodeNotPrompt/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78854345），请尊重他人的辛勤劳动成果，谢谢 当出现AndroidStudio导入网上下载的代码慢及AndroidStudio不提示代码时，多数是因为Google被墙，导致gradle无法更新下来。 解决的方法是，先在本地创建一个Android项目，然后找到 随后再找到 完成这两步的目的是，通过找到本地的gradle配置，将网上下载的不同配置的项目的gradle配置改成读本地配置，来解决Google被墙无法更新网上可行版本的问题。通常设置完这两个地方，再点击一下AndroidStudio上方工具栏里的BuiId下的Clean Project ，结束后点击RebuiId Project,然后再点击一下这个按钮， 同步一下，问题就可以解决了 一般来说，网上下载的项目更新慢，或编译器无代码提示，都是因为这个原因引起。","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Android第三方分享集成","slug":"AndroidThirdShare","date":"2014-03-18T03:55:21.000Z","updated":"2018-03-18T04:00:49.647Z","comments":true,"path":"2014/03/18/AndroidThirdShare/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/03/18/AndroidThirdShare/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78818943），请尊重他人的辛勤劳动成果，谢谢 一、环境集成 二、调用方法 一、环境集成 请看我的另一篇文章，里面详尽的介绍了整个集成的流程。分享只是在那个前提下多写一个分享的方法。 文章链接：http://blog.csdn.net/weimeig/article/details/78818085 二、调用方法 `/** * 第三方分享方法 * Created by weimei on 2017/12/16. * Email:ucvs@qq.com */ public void share(){ OnekeyShare oks = new OnekeyShare(); //关闭sso授权 oks.disableSSOWhenAuthorize(); // 分享时Notification的图标和文字 2.5.9以后的版本不 调用此方法 //oks.setNotification(R.drawable.ic_launcher, getString(R.string.app_name)); // title标题，印象笔记、邮箱、信息、微信、人人网和QQ空间使用 oks.setTitle(&quot;分享&quot;); // titleUrl是标题的网络链接，仅在人人网和QQ空间使用 oks.setTitleUrl(&quot;http://blog.csdn.net/weimeig&quot;); // text是分享文本，所有平台都需要这个字段 oks.setText(&quot;我是分享文本&quot;); // imagePath是图片的本地路径，Linked-In以外的平台都支持此参数 oks.setImageUrl(&quot;http://www.ld12.com/upimg358/20160130/23120952396496.jpg&quot;);//确保SDcard下面存在此张图片 // url仅在微信（包括好友和朋友圈）中使用 oks.setUrl(&quot;http://blog.csdn.net/weimeig&quot;); // comment是我对这条分享的评论，仅在人人网和QQ空间使用 oks.setComment(&quot;我是测试评论文本&quot;); // site是分享此内容的网站名称，仅在QQ空间使用 oks.setSite(getString(R.string.app_name)); // siteUrl是分享此内容的网站地址，仅在QQ空间使用 oks.setSiteUrl(&quot;http://blog.csdn.net/weimeig&quot;); oks.setCallback(new PlatformActionListener() { @Override public void onComplete(Platform platform, int i, HashMap&lt;String, Object&gt; hashMap) { /** * 不得到优惠券 */ //分享成功逻辑在这里处理 } @Override public void onError(Platform platform, int i, Throwable throwable) { //分享失败逻辑在这里处理 } @Override public void onCancel(Platform platform, int i) { //分享取消逻辑在这里处理 } }); // 启动分享GUI oks.show(this); }` 调用时候，在调用的地方使用 share(); 即可 如果分享的图标和渠道，不想要那么多，在项目下的app文件夹下的libs文件夹内删除对应的jar包即可。 例如不想要微信分享，直接删除ShareSDK-Wechat-Favorite-3.1.2.jar这个jar包，分享的时候就没有这个图标和对应的分享渠道了。 项目Demo下载 http://download.csdn.net/download/weimeig/10161093","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Android第三方登录集成","slug":"AndroidThirdLogin","date":"2014-03-16T19:40:19.000Z","updated":"2018-03-18T03:56:07.999Z","comments":true,"path":"2014/03/17/AndroidThirdLogin/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/03/17/AndroidThirdLogin/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78818085）， 请尊重他人的辛勤劳动成果，谢谢 ShareSDK集成 一、集成 二、第三方开发平台注册 三、项目中使用 一、集成 到mob.com下载ShareSDK，选择要集成的功能并下载，下载好后，解压，并点击QuickIntegrater.rar生成需要功能，得到Sample文件夹，生成时候记得填写项目包名才点击生成，不然会报错。 （1）将Sample文件夹的libs文件夹里的jar包复制到项目下的app文件夹下的libs文件夹内。 （2）res文件夹内的文件，不做任何改名更改，复制到项目下的app文件夹下的res文件夹内。 （3）将ShareSDK.xml文件复制到项目下的app文件夹下的src下的main文件夹下的assets文件夹中，如果没有这个文件夹则创建一个。 （4）将src文件夹内复制到项目下的app文件夹下的src下的main文件夹下的java文件夹中，与自己原包名项目并列。 （5）更改AndroidManifest.xml文件内应用权限，照着官方文档填写即可，或者下载本文提供的demo，从demo中复制AndroidManifest.xml文件内权限到自己的项目 ( 6 )AndroidManifest.xml文件内设置您从Mob开发者后台中得到的Appkey和AppSecret，如 此时如果有地方报红，点击AndroidStudio上方工具栏里的BuiId下的Clean Project ，结束后点击RebuiId Project,然后再点击一下这个按钮， 原因是新引入的包需要同步一下，就不报红了。 集成完成。 二、第三方开发平台注册 如需要集成第三方登录是QQ、微信、微博。则分别到对应的第三方开放平台注册账号，如微信是微信第三方开放平台，在平台选择开启登录功能，然后填写完应用相关信息后，得到AppId和AppSecret将两者保存下来，一会第三步要用到。这里需要注意的是，平台填写的应用信息中，包名和应用签名，要和app对应。最后面附上怎么查看应用签名的方法。 特别注明：新浪微博的话，还需要在开放平台里选择回调接口地址，在开放平台应用信息附近找到OAuth2.0 授权设置编辑，设置微博回调地址。 比如官方默认的回调地址（默认的也可以使用）： 授权回调页：http://sns.whalecloud.com/sina2/callback取消授权回调页：http://sns.whalecloud.com/sina2/callback 三、项目中使用 （1）将你在第三方开发平台申请到的AppId和AppSecret填写到src下的main文件夹下的assets文件夹内的ShareSDK.xml文件中，替换掉mob提供的初始的。微博的话，还需要在这个文件里面的微博的配置里，设置RedirectUrl这个参数，微博官方默认的是 RedirectUrl=”http://sns.whalecloud.com/sina2/callback&quot; 如果你申请开发平台时用了默认的，可以设置为这个 （2）第三方登录的方法 `/** * 第三方登录方法 * Created by weimei on 2017/12/16. * Email:ucvs@qq.com */ private void thirdLogin(String platformName,final String backType) { Platform wechat = ShareSDK.getPlatform(platformName); wechat.SSOSetting(false); //设置false表示使用SSO授权方式 if(wechat.isAuthValid()){ wechat.removeAccount(true); } wechat.setPlatformActionListener(new PlatformActionListener() { @Override public void onComplete(Platform platform, int i, HashMap&lt;String, Object&gt; hashMap) { Log.d(TAG, &quot;onComplete: &quot;+i+new Gson().toJson(hashMap)); if (i == Platform.ACTION_USER_INFOR) { final PlatformDb platDB = platform.getDb();//获取数平台数据DB //通过DB获取各种数据 platDB.getToken(); platDB.getUserGender(); platDB.getUserIcon(); platDB.getUserId(); platDB.getUserName(); Log.d(TAG, &quot;onComplete: &quot;+ platDB.getToken()+&quot;-&quot;+ platDB.getUserId()+&quot;-&quot;+ platDB.getUserName()); runOnUiThread(new Runnable() { @Override public void run() { // platDB.getUserId()是唯一的 //这里写你的业务逻辑，如网络请求 // mPresenter.trilateralLogin(backType,platDB.getUserId(),platDB.getUserName(), // platDB.getUserIcon(),platDB.getUserGender(),LoginActivity.this); } }); } } @Override public void onError(Platform platform, int i, Throwable throwable) { Log.d(TAG, &quot;onError: &quot;+throwable.toString()); } @Override public void onCancel(Platform platform, int i) { /** * 给用户取消的提示 */ } }); // 设置分享事件回调 wechat.authorize();//单独授权 wechat.showUser(null); }` 然后在需要使用第三方登录的地方调用该方法即可 如果此时报红，则用第一步教的那个方法，同步一下，就不报红了。 此时 QQ调用时，如： thirdLogin(QQ.NAME,&quot;AndroidQQ&quot;); 微信调用时，如： thirdLogin(Wechat.NAME,&quot;AndroidWechat&quot;); 微博调用时，如： thirdLogin(SinaWeibo.NAME,&quot;Androidweibo&quot;); 其中第一个参数的，如：QQ.NAME，是第三方规定的，不可随意更改，第二个参数，是来源，如果你后台的url不需要这个参数，直接删除即可，同时也在thirdLogin方法里面删除即可。 附：查看应用签名的方法。 用密钥打包apk，打包的时候，选择生成release版本，切记不要生成debug版本。然后安装到手机中。 同时安装下面提供的这个apk。打开这个apk，输入你的应用包名，点击生成，生成的这个就是你的安卓签名。 注意这个是要用你发布app的那个密钥去生成apk，并且输入的包名和你发布的app的包名一致，满足这两个要求前提下，才能生成一致的安卓签名。 安卓签名生成软件 http://download.csdn.net/download/weimeig/10161075 项目Demo下载 http://download.csdn.net/download/weimeig/10161093","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]}]}